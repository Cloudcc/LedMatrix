
RGB_led.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001d14  10001000  10001000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .VENEER_Code  00000110  2000000c  10002d14  0000800c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 Stack         00000404  2000011c  00000000  0000011c  2**0
                  ALLOC
  3 .data         000000b8  20000520  10002e24  00008520  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000028  200005d8  10002edc  000085d8  2**2
                  ALLOC
  5 .no_init      00000004  20003ffc  10006900  000085d8  2**2
                  ALLOC
  6 .debug_aranges 00000770  00000000  00000000  000085d8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000afdd  00000000  00000000  00008d48  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001b05  00000000  00000000  00013d25  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00003256  00000000  00000000  0001582a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000017c0  00000000  00000000  00018a80  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000526e  00000000  00000000  0001a240  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000265e  00000000  00000000  0001f4ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000638  00000000  00000000  00021b10  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .build_attributes 000003fb  00000000  00000000  00022148  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

10001000 <__Vectors>:
10001000:	20 05 00 20 19 10 00 10 00 00 00 00 99 10 00 10      .. ............
10001010:	00 04 01 00 00 00 00 80                             ........

10001018 <Reset_Handler>:
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001018:	4911      	ldr	r1, [pc, #68]	; (10001060 <__copy_data+0xe>)
	ldr	r2, =VeneerStart
1000101a:	4a12      	ldr	r2, [pc, #72]	; (10001064 <__copy_data+0x12>)
	ldr	r3, =VeneerEnd
1000101c:	4b12      	ldr	r3, [pc, #72]	; (10001068 <__copy_data+0x16>)
	bl  __copy_data
1000101e:	f000 f818 	bl	10001052 <__copy_data>

    ldr  r0, =SystemInit
10001022:	4812      	ldr	r0, [pc, #72]	; (1000106c <__copy_data+0x1a>)
    blx  r0
10001024:	4780      	blx	r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001026:	4912      	ldr	r1, [pc, #72]	; (10001070 <__copy_data+0x1e>)
	ldr	r2, =__data_start
10001028:	4a12      	ldr	r2, [pc, #72]	; (10001074 <__copy_data+0x22>)
	ldr	r3, =__data_end
1000102a:	4b13      	ldr	r3, [pc, #76]	; (10001078 <__copy_data+0x26>)
	bl  __copy_data
1000102c:	f000 f811 	bl	10001052 <__copy_data>

/* RAM code */
	ldr	r1, =__ram_code_load
10001030:	4912      	ldr	r1, [pc, #72]	; (1000107c <__copy_data+0x2a>)
	ldr	r2, =__ram_code_start
10001032:	4a13      	ldr	r2, [pc, #76]	; (10001080 <__copy_data+0x2e>)
	ldr	r3, =__ram_code_end
10001034:	4b13      	ldr	r3, [pc, #76]	; (10001084 <__copy_data+0x32>)
	bl  __copy_data
10001036:	f000 f80c 	bl	10001052 <__copy_data>
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000103a:	4913      	ldr	r1, [pc, #76]	; (10001088 <__copy_data+0x36>)
	ldr	r2, =__bss_end
1000103c:	4a13      	ldr	r2, [pc, #76]	; (1000108c <__copy_data+0x3a>)

	movs	r0, 0
1000103e:	2000      	movs	r0, #0

	subs	r2, r1
10001040:	1a52      	subs	r2, r2, r1
	ble	.L_loop3_done
10001042:	dd02      	ble.n	1000104a <Reset_Handler+0x32>

.L_loop3:
	subs	r2, #4
10001044:	3a04      	subs	r2, #4
	str	r0, [r1, r2]
10001046:	5088      	str	r0, [r1, r2]
	bgt	.L_loop3
10001048:	dcfc      	bgt.n	10001044 <Reset_Handler+0x2c>
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
1000104a:	4811      	ldr	r0, [pc, #68]	; (10001090 <__copy_data+0x3e>)
    blx  r0
1000104c:	4780      	blx	r0
#endif

    ldr  r0, =main
1000104e:	4811      	ldr	r0, [pc, #68]	; (10001094 <__copy_data+0x42>)
    blx  r0
10001050:	4780      	blx	r0

10001052 <__copy_data>:
 *    r3: end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 *  Uses r0
 */
	subs	r3, r2
10001052:	1a9b      	subs	r3, r3, r2
	ble	.L_loop_done
10001054:	dd03      	ble.n	1000105e <__copy_data+0xc>

.L_loop:
	subs	r3, #4
10001056:	3b04      	subs	r3, #4
	ldr	r0, [r1,r3]
10001058:	58c8      	ldr	r0, [r1, r3]
	str	r0, [r2,r3]
1000105a:	50d0      	str	r0, [r2, r3]
	bgt	.L_loop
1000105c:	dcfb      	bgt.n	10001056 <__copy_data+0x4>

.L_loop_done:
	bx  lr
1000105e:	4770      	bx	lr
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001060:	10002d14 	.word	0x10002d14
	ldr	r2, =VeneerStart
10001064:	2000000c 	.word	0x2000000c
	ldr	r3, =VeneerEnd
10001068:	2000011c 	.word	0x2000011c
	bl  __copy_data

    ldr  r0, =SystemInit
1000106c:	1000109d 	.word	0x1000109d
    blx  r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001070:	10002e24 	.word	0x10002e24
	ldr	r2, =__data_start
10001074:	20000520 	.word	0x20000520
	ldr	r3, =__data_end
10001078:	200005d8 	.word	0x200005d8
	bl  __copy_data

/* RAM code */
	ldr	r1, =__ram_code_load
1000107c:	10002edc 	.word	0x10002edc
	ldr	r2, =__ram_code_start
10001080:	200005d8 	.word	0x200005d8
	ldr	r3, =__ram_code_end
10001084:	200005d8 	.word	0x200005d8
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
10001088:	200005d8 	.word	0x200005d8
	ldr	r2, =__bss_end
1000108c:	20000600 	.word	0x20000600
	bgt	.L_loop3
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
10001090:	10002c01 	.word	0x10002c01
    blx  r0
#endif

    ldr  r0, =main
10001094:	1000293d 	.word	0x1000293d

10001098 <CCU40_0_IRQHandler>:
    
    .thumb_func
    .weak Default_handler
    .type Default_handler, %function
Default_handler:
    b  .
10001098:	e7fe      	b.n	10001098 <CCU40_0_IRQHandler>
	...

1000109c <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{    
1000109c:	b580      	push	{r7, lr}
1000109e:	af00      	add	r7, sp, #0
  SystemCoreSetup();
100010a0:	f001 fbac 	bl	100027fc <SystemCoreSetup>
  SystemCoreClockSetup();
100010a4:	f001 fbf0 	bl	10002888 <SystemCoreClockSetup>
}
100010a8:	46bd      	mov	sp, r7
100010aa:	bd80      	pop	{r7, pc}

100010ac <SystemCoreClockUpdate>:
  
  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
100010ac:	b580      	push	{r7, lr}
100010ae:	af00      	add	r7, sp, #0
  static uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
100010b0:	4b12      	ldr	r3, [pc, #72]	; (100010fc <SystemCoreClockUpdate+0x50>)
100010b2:	681a      	ldr	r2, [r3, #0]
100010b4:	23ff      	movs	r3, #255	; 0xff
100010b6:	021b      	lsls	r3, r3, #8
100010b8:	4013      	ands	r3, r2
100010ba:	0a1a      	lsrs	r2, r3, #8
100010bc:	4b10      	ldr	r3, [pc, #64]	; (10001100 <SystemCoreClockUpdate+0x54>)
100010be:	601a      	str	r2, [r3, #0]
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
100010c0:	4b0e      	ldr	r3, [pc, #56]	; (100010fc <SystemCoreClockUpdate+0x50>)
100010c2:	681b      	ldr	r3, [r3, #0]
100010c4:	22ff      	movs	r2, #255	; 0xff
100010c6:	401a      	ands	r2, r3
100010c8:	4b0e      	ldr	r3, [pc, #56]	; (10001104 <SystemCoreClockUpdate+0x58>)
100010ca:	601a      	str	r2, [r3, #0]
  
  if (IDIV != 0)
100010cc:	4b0c      	ldr	r3, [pc, #48]	; (10001100 <SystemCoreClockUpdate+0x54>)
100010ce:	681b      	ldr	r3, [r3, #0]
100010d0:	2b00      	cmp	r3, #0
100010d2:	d00e      	beq.n	100010f2 <SystemCoreClockUpdate+0x46>
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((DCO1_FREQUENCY << 6U) / ((IDIV << 8) + FDIV)) << 1U;
100010d4:	4b0a      	ldr	r3, [pc, #40]	; (10001100 <SystemCoreClockUpdate+0x54>)
100010d6:	681b      	ldr	r3, [r3, #0]
100010d8:	021a      	lsls	r2, r3, #8
100010da:	4b0a      	ldr	r3, [pc, #40]	; (10001104 <SystemCoreClockUpdate+0x58>)
100010dc:	681b      	ldr	r3, [r3, #0]
100010de:	18d3      	adds	r3, r2, r3
100010e0:	4809      	ldr	r0, [pc, #36]	; (10001108 <SystemCoreClockUpdate+0x5c>)
100010e2:	1c19      	adds	r1, r3, #0
100010e4:	f001 fcfa 	bl	10002adc <__aeabi_uidiv>
100010e8:	1c03      	adds	r3, r0, #0
100010ea:	005a      	lsls	r2, r3, #1
100010ec:	4b07      	ldr	r3, [pc, #28]	; (1000110c <SystemCoreClockUpdate+0x60>)
100010ee:	601a      	str	r2, [r3, #0]
100010f0:	e002      	b.n	100010f8 <SystemCoreClockUpdate+0x4c>
  }
  else
  {
    /* Fractional divider bypassed. Simply divide DCO_DCLK by 2 */
    SystemCoreClock = DCO1_FREQUENCY >> 1U;
100010f2:	4b06      	ldr	r3, [pc, #24]	; (1000110c <SystemCoreClockUpdate+0x60>)
100010f4:	4a06      	ldr	r2, [pc, #24]	; (10001110 <SystemCoreClockUpdate+0x64>)
100010f6:	601a      	str	r2, [r3, #0]
  }
}
100010f8:	46bd      	mov	sp, r7
100010fa:	bd80      	pop	{r7, pc}
100010fc:	40010300 	.word	0x40010300
10001100:	200005d8 	.word	0x200005d8
10001104:	200005dc 	.word	0x200005dc
10001108:	f4240000 	.word	0xf4240000
1000110c:	20003ffc 	.word	0x20003ffc
10001110:	01e84800 	.word	0x01e84800

10001114 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
10001114:	b590      	push	{r4, r7, lr}
10001116:	b085      	sub	sp, #20
10001118:	af00      	add	r7, sp, #0
1000111a:	60f8      	str	r0, [r7, #12]
1000111c:	607a      	str	r2, [r7, #4]
1000111e:	230b      	movs	r3, #11
10001120:	18fb      	adds	r3, r7, r3
10001122:	1c0a      	adds	r2, r1, #0
10001124:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));
  
  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
10001126:	230b      	movs	r3, #11
10001128:	18fb      	adds	r3, r7, r3
1000112a:	781b      	ldrb	r3, [r3, #0]
1000112c:	089b      	lsrs	r3, r3, #2
1000112e:	b2db      	uxtb	r3, r3
10001130:	1c18      	adds	r0, r3, #0
10001132:	230b      	movs	r3, #11
10001134:	18fb      	adds	r3, r7, r3
10001136:	781b      	ldrb	r3, [r3, #0]
10001138:	089b      	lsrs	r3, r3, #2
1000113a:	b2db      	uxtb	r3, r3
1000113c:	1c1a      	adds	r2, r3, #0
1000113e:	68fb      	ldr	r3, [r7, #12]
10001140:	3204      	adds	r2, #4
10001142:	0092      	lsls	r2, r2, #2
10001144:	58d3      	ldr	r3, [r2, r3]
10001146:	220b      	movs	r2, #11
10001148:	18ba      	adds	r2, r7, r2
1000114a:	7812      	ldrb	r2, [r2, #0]
1000114c:	2103      	movs	r1, #3
1000114e:	400a      	ands	r2, r1
10001150:	00d2      	lsls	r2, r2, #3
10001152:	1c11      	adds	r1, r2, #0
10001154:	22f8      	movs	r2, #248	; 0xf8
10001156:	408a      	lsls	r2, r1
10001158:	43d2      	mvns	r2, r2
1000115a:	401a      	ands	r2, r3
1000115c:	1c11      	adds	r1, r2, #0
1000115e:	68fb      	ldr	r3, [r7, #12]
10001160:	1d02      	adds	r2, r0, #4
10001162:	0092      	lsls	r2, r2, #2
10001164:	50d1      	str	r1, [r2, r3]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
10001166:	68fb      	ldr	r3, [r7, #12]
10001168:	6f5b      	ldr	r3, [r3, #116]	; 0x74
1000116a:	220b      	movs	r2, #11
1000116c:	18ba      	adds	r2, r7, r2
1000116e:	7812      	ldrb	r2, [r2, #0]
10001170:	0052      	lsls	r2, r2, #1
10001172:	1c11      	adds	r1, r2, #0
10001174:	2203      	movs	r2, #3
10001176:	408a      	lsls	r2, r1
10001178:	43d2      	mvns	r2, r2
1000117a:	401a      	ands	r2, r3
1000117c:	68fb      	ldr	r3, [r7, #12]
1000117e:	675a      	str	r2, [r3, #116]	; 0x74

  /* Set input hysteresis */
  port->PHCR[(uint32_t)pin >> 3U] &= ~(uint32_t)((uint32_t)PORT_PHCR_Msk << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U)));
10001180:	230b      	movs	r3, #11
10001182:	18fb      	adds	r3, r7, r3
10001184:	781b      	ldrb	r3, [r3, #0]
10001186:	08db      	lsrs	r3, r3, #3
10001188:	b2db      	uxtb	r3, r3
1000118a:	1c18      	adds	r0, r3, #0
1000118c:	230b      	movs	r3, #11
1000118e:	18fb      	adds	r3, r7, r3
10001190:	781b      	ldrb	r3, [r3, #0]
10001192:	08db      	lsrs	r3, r3, #3
10001194:	b2db      	uxtb	r3, r3
10001196:	1c1a      	adds	r2, r3, #0
10001198:	68fb      	ldr	r3, [r7, #12]
1000119a:	3210      	adds	r2, #16
1000119c:	0092      	lsls	r2, r2, #2
1000119e:	58d3      	ldr	r3, [r2, r3]
100011a0:	220b      	movs	r2, #11
100011a2:	18ba      	adds	r2, r7, r2
100011a4:	7812      	ldrb	r2, [r2, #0]
100011a6:	2107      	movs	r1, #7
100011a8:	400a      	ands	r2, r1
100011aa:	0092      	lsls	r2, r2, #2
100011ac:	1c11      	adds	r1, r2, #0
100011ae:	2204      	movs	r2, #4
100011b0:	408a      	lsls	r2, r1
100011b2:	43d2      	mvns	r2, r2
100011b4:	401a      	ands	r2, r3
100011b6:	1c11      	adds	r1, r2, #0
100011b8:	68fb      	ldr	r3, [r7, #12]
100011ba:	1c02      	adds	r2, r0, #0
100011bc:	3210      	adds	r2, #16
100011be:	0092      	lsls	r2, r2, #2
100011c0:	50d1      	str	r1, [r2, r3]
  port->PHCR[(uint32_t)pin >> 3U] |= (uint32_t)config->input_hysteresis << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U));
100011c2:	230b      	movs	r3, #11
100011c4:	18fb      	adds	r3, r7, r3
100011c6:	781b      	ldrb	r3, [r3, #0]
100011c8:	08db      	lsrs	r3, r3, #3
100011ca:	b2db      	uxtb	r3, r3
100011cc:	1c18      	adds	r0, r3, #0
100011ce:	230b      	movs	r3, #11
100011d0:	18fb      	adds	r3, r7, r3
100011d2:	781b      	ldrb	r3, [r3, #0]
100011d4:	08db      	lsrs	r3, r3, #3
100011d6:	b2db      	uxtb	r3, r3
100011d8:	1c1a      	adds	r2, r3, #0
100011da:	68fb      	ldr	r3, [r7, #12]
100011dc:	3210      	adds	r2, #16
100011de:	0092      	lsls	r2, r2, #2
100011e0:	58d2      	ldr	r2, [r2, r3]
100011e2:	687b      	ldr	r3, [r7, #4]
100011e4:	785b      	ldrb	r3, [r3, #1]
100011e6:	1c1c      	adds	r4, r3, #0
100011e8:	230b      	movs	r3, #11
100011ea:	18fb      	adds	r3, r7, r3
100011ec:	781b      	ldrb	r3, [r3, #0]
100011ee:	2107      	movs	r1, #7
100011f0:	400b      	ands	r3, r1
100011f2:	009b      	lsls	r3, r3, #2
100011f4:	409c      	lsls	r4, r3
100011f6:	1c23      	adds	r3, r4, #0
100011f8:	431a      	orrs	r2, r3
100011fa:	1c11      	adds	r1, r2, #0
100011fc:	68fb      	ldr	r3, [r7, #12]
100011fe:	1c02      	adds	r2, r0, #0
10001200:	3210      	adds	r2, #16
10001202:	0092      	lsls	r2, r2, #2
10001204:	50d1      	str	r1, [r2, r3]
    
  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
10001206:	68fb      	ldr	r3, [r7, #12]
10001208:	4a1d      	ldr	r2, [pc, #116]	; (10001280 <XMC_GPIO_Init+0x16c>)
1000120a:	4293      	cmp	r3, r2
1000120c:	d10b      	bne.n	10001226 <XMC_GPIO_Init+0x112>
  {    
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
1000120e:	68fb      	ldr	r3, [r7, #12]
10001210:	6e1b      	ldr	r3, [r3, #96]	; 0x60
10001212:	220b      	movs	r2, #11
10001214:	18ba      	adds	r2, r7, r2
10001216:	7812      	ldrb	r2, [r2, #0]
10001218:	2101      	movs	r1, #1
1000121a:	4091      	lsls	r1, r2
1000121c:	1c0a      	adds	r2, r1, #0
1000121e:	43d2      	mvns	r2, r2
10001220:	401a      	ands	r2, r3
10001222:	68fb      	ldr	r3, [r7, #12]
10001224:	661a      	str	r2, [r3, #96]	; 0x60
  }
  /* Set output level */
  port->OMR = (uint32_t)config->output_level << pin;
10001226:	687b      	ldr	r3, [r7, #4]
10001228:	685a      	ldr	r2, [r3, #4]
1000122a:	230b      	movs	r3, #11
1000122c:	18fb      	adds	r3, r7, r3
1000122e:	781b      	ldrb	r3, [r3, #0]
10001230:	409a      	lsls	r2, r3
10001232:	68fb      	ldr	r3, [r7, #12]
10001234:	605a      	str	r2, [r3, #4]
  
  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << (PORT_IOCR_PC_Size * (pin & 0x3U));
10001236:	230b      	movs	r3, #11
10001238:	18fb      	adds	r3, r7, r3
1000123a:	781b      	ldrb	r3, [r3, #0]
1000123c:	089b      	lsrs	r3, r3, #2
1000123e:	b2db      	uxtb	r3, r3
10001240:	1c18      	adds	r0, r3, #0
10001242:	230b      	movs	r3, #11
10001244:	18fb      	adds	r3, r7, r3
10001246:	781b      	ldrb	r3, [r3, #0]
10001248:	089b      	lsrs	r3, r3, #2
1000124a:	b2db      	uxtb	r3, r3
1000124c:	1c1a      	adds	r2, r3, #0
1000124e:	68fb      	ldr	r3, [r7, #12]
10001250:	3204      	adds	r2, #4
10001252:	0092      	lsls	r2, r2, #2
10001254:	58d2      	ldr	r2, [r2, r3]
10001256:	687b      	ldr	r3, [r7, #4]
10001258:	781b      	ldrb	r3, [r3, #0]
1000125a:	1c1c      	adds	r4, r3, #0
1000125c:	230b      	movs	r3, #11
1000125e:	18fb      	adds	r3, r7, r3
10001260:	781b      	ldrb	r3, [r3, #0]
10001262:	2103      	movs	r1, #3
10001264:	400b      	ands	r3, r1
10001266:	00db      	lsls	r3, r3, #3
10001268:	409c      	lsls	r4, r3
1000126a:	1c23      	adds	r3, r4, #0
1000126c:	431a      	orrs	r2, r3
1000126e:	1c11      	adds	r1, r2, #0
10001270:	68fb      	ldr	r3, [r7, #12]
10001272:	1d02      	adds	r2, r0, #4
10001274:	0092      	lsls	r2, r2, #2
10001276:	50d1      	str	r1, [r2, r3]
}
10001278:	46bd      	mov	sp, r7
1000127a:	b005      	add	sp, #20
1000127c:	bd90      	pop	{r4, r7, pc}
1000127e:	46c0      	nop			; (mov r8, r8)
10001280:	40040200 	.word	0x40040200

10001284 <XMC_SCU_LockProtectedBits>:
#endif
}

/* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
10001284:	b580      	push	{r7, lr}
10001286:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
10001288:	4b02      	ldr	r3, [pc, #8]	; (10001294 <XMC_SCU_LockProtectedBits+0x10>)
1000128a:	22c3      	movs	r2, #195	; 0xc3
1000128c:	625a      	str	r2, [r3, #36]	; 0x24
}
1000128e:	46bd      	mov	sp, r7
10001290:	bd80      	pop	{r7, pc}
10001292:	46c0      	nop			; (mov r8, r8)
10001294:	40010000 	.word	0x40010000

10001298 <XMC_SCU_UnlockProtectedBits>:

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
10001298:	b580      	push	{r7, lr}
1000129a:	af00      	add	r7, sp, #0
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
1000129c:	4b05      	ldr	r3, [pc, #20]	; (100012b4 <XMC_SCU_UnlockProtectedBits+0x1c>)
1000129e:	22c0      	movs	r2, #192	; 0xc0
100012a0:	625a      	str	r2, [r3, #36]	; 0x24

  while(((SCU_GENERAL->PASSWD) & SCU_GENERAL_PASSWD_PROTS_Msk))
100012a2:	46c0      	nop			; (mov r8, r8)
100012a4:	4b03      	ldr	r3, [pc, #12]	; (100012b4 <XMC_SCU_UnlockProtectedBits+0x1c>)
100012a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100012a8:	2204      	movs	r2, #4
100012aa:	4013      	ands	r3, r2
100012ac:	d1fa      	bne.n	100012a4 <XMC_SCU_UnlockProtectedBits+0xc>
  {
    /* Loop until the lock is removed */
  }
}
100012ae:	46bd      	mov	sp, r7
100012b0:	bd80      	pop	{r7, pc}
100012b2:	46c0      	nop			; (mov r8, r8)
100012b4:	40010000 	.word	0x40010000

100012b8 <XMC_SCU_CLOCK_Init>:
}


/* API which initializes the clock tree ofthe device */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
100012b8:	b580      	push	{r7, lr}
100012ba:	b082      	sub	sp, #8
100012bc:	af00      	add	r7, sp, #0
100012be:	6078      	str	r0, [r7, #4]
  /* Remove protection */
  XMC_SCU_UnlockProtectedBits();
100012c0:	f7ff ffea 	bl	10001298 <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100012c4:	4a0c      	ldr	r2, [pc, #48]	; (100012f8 <XMC_SCU_CLOCK_Init+0x40>)
100012c6:	4b0c      	ldr	r3, [pc, #48]	; (100012f8 <XMC_SCU_CLOCK_Init+0x40>)
100012c8:	681b      	ldr	r3, [r3, #0]
100012ca:	490c      	ldr	r1, [pc, #48]	; (100012fc <XMC_SCU_CLOCK_Init+0x44>)
100012cc:	4019      	ands	r1, r3
                   config->rtc_src |
100012ce:	687b      	ldr	r3, [r7, #4]
100012d0:	689b      	ldr	r3, [r3, #8]
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100012d2:	4319      	orrs	r1, r3
                   config->rtc_src |
                   config->pclk_src;
100012d4:	687b      	ldr	r3, [r7, #4]
100012d6:	685b      	ldr	r3, [r3, #4]
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
                   config->rtc_src |
100012d8:	430b      	orrs	r3, r1
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100012da:	6013      	str	r3, [r2, #0]
                   config->rtc_src |
                   config->pclk_src;

  /* Close the lock opened above. */
  XMC_SCU_LockProtectedBits();
100012dc:	f7ff ffd2 	bl	10001284 <XMC_SCU_LockProtectedBits>

  /* Update the dividers now */
  XMC_SCU_CLOCK_ScaleMCLKFrequency(config->idiv, config->fdiv);
100012e0:	687b      	ldr	r3, [r7, #4]
100012e2:	785b      	ldrb	r3, [r3, #1]
100012e4:	1c1a      	adds	r2, r3, #0
100012e6:	687b      	ldr	r3, [r7, #4]
100012e8:	781b      	ldrb	r3, [r3, #0]
100012ea:	1c10      	adds	r0, r2, #0
100012ec:	1c19      	adds	r1, r3, #0
100012ee:	f000 f825 	bl	1000133c <XMC_SCU_CLOCK_ScaleMCLKFrequency>

}
100012f2:	46bd      	mov	sp, r7
100012f4:	b002      	add	sp, #8
100012f6:	bd80      	pop	{r7, pc}
100012f8:	40010300 	.word	0x40010300
100012fc:	fff0ffff 	.word	0xfff0ffff

10001300 <XMC_SCU_CLOCK_UngatePeripheralClock>:
  XMC_SCU_LockProtectedBits();
}

/* API which ungates a clock note at its source */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
10001300:	b580      	push	{r7, lr}
10001302:	b082      	sub	sp, #8
10001304:	af00      	add	r7, sp, #0
10001306:	1c02      	adds	r2, r0, #0
10001308:	1dbb      	adds	r3, r7, #6
1000130a:	801a      	strh	r2, [r3, #0]
  XMC_SCU_UnlockProtectedBits();
1000130c:	f7ff ffc4 	bl	10001298 <XMC_SCU_UnlockProtectedBits>
  SCU_CLK->CGATCLR0 |= (uint32_t)peripheral;
10001310:	4b09      	ldr	r3, [pc, #36]	; (10001338 <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
10001312:	4a09      	ldr	r2, [pc, #36]	; (10001338 <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
10001314:	6911      	ldr	r1, [r2, #16]
10001316:	1dba      	adds	r2, r7, #6
10001318:	8812      	ldrh	r2, [r2, #0]
1000131a:	430a      	orrs	r2, r1
1000131c:	611a      	str	r2, [r3, #16]
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
1000131e:	46c0      	nop			; (mov r8, r8)
10001320:	4b05      	ldr	r3, [pc, #20]	; (10001338 <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
10001322:	681a      	ldr	r2, [r3, #0]
10001324:	2380      	movs	r3, #128	; 0x80
10001326:	05db      	lsls	r3, r3, #23
10001328:	4013      	ands	r3, r2
1000132a:	d1f9      	bne.n	10001320 <XMC_SCU_CLOCK_UngatePeripheralClock+0x20>
  {
    /* Wait voltage suply stabilization */
  }
  XMC_SCU_LockProtectedBits();
1000132c:	f7ff ffaa 	bl	10001284 <XMC_SCU_LockProtectedBits>
}
10001330:	46bd      	mov	sp, r7
10001332:	b002      	add	sp, #8
10001334:	bd80      	pop	{r7, pc}
10001336:	46c0      	nop			; (mov r8, r8)
10001338:	40010300 	.word	0x40010300

1000133c <XMC_SCU_CLOCK_ScaleMCLKFrequency>:
}


/* A utility routine which updates the fractional dividers in steps */
void XMC_SCU_CLOCK_ScaleMCLKFrequency(uint32_t idiv, uint32_t fdiv)
{
1000133c:	b580      	push	{r7, lr}
1000133e:	b084      	sub	sp, #16
10001340:	af00      	add	r7, sp, #0
10001342:	6078      	str	r0, [r7, #4]
10001344:	6039      	str	r1, [r7, #0]
  /* Find out current and target value of idiv */
  uint32_t curr_idiv;

  XMC_SCU_UnlockProtectedBits();
10001346:	f7ff ffa7 	bl	10001298 <XMC_SCU_UnlockProtectedBits>

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
1000134a:	4b21      	ldr	r3, [pc, #132]	; (100013d0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
1000134c:	681a      	ldr	r2, [r3, #0]
1000134e:	23ff      	movs	r3, #255	; 0xff
10001350:	021b      	lsls	r3, r3, #8
10001352:	4013      	ands	r3, r2
10001354:	0a1b      	lsrs	r3, r3, #8
10001356:	60fb      	str	r3, [r7, #12]

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001358:	4b1d      	ldr	r3, [pc, #116]	; (100013d0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
1000135a:	4a1d      	ldr	r2, [pc, #116]	; (100013d0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
1000135c:	6812      	ldr	r2, [r2, #0]
1000135e:	491d      	ldr	r1, [pc, #116]	; (100013d4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x98>)
10001360:	4011      	ands	r1, r2
10001362:	683a      	ldr	r2, [r7, #0]
10001364:	430a      	orrs	r2, r1
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
10001366:	491c      	ldr	r1, [pc, #112]	; (100013d8 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x9c>)
10001368:	430a      	orrs	r2, r1

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000136a:	601a      	str	r2, [r3, #0]
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#endif

  while ((SCU_CLK->CLKCR)& SCU_CLK_CLKCR_VDDC2LOW_Msk)
1000136c:	46c0      	nop			; (mov r8, r8)
1000136e:	4b18      	ldr	r3, [pc, #96]	; (100013d0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
10001370:	681a      	ldr	r2, [r3, #0]
10001372:	2380      	movs	r3, #128	; 0x80
10001374:	05db      	lsls	r3, r3, #23
10001376:	4013      	ands	r3, r2
10001378:	d1f9      	bne.n	1000136e <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x32>
  {
    /* Spin until the core supply stabilizes */
  }

  if(curr_idiv <= idiv)
1000137a:	68fa      	ldr	r2, [r7, #12]
1000137c:	687b      	ldr	r3, [r7, #4]
1000137e:	429a      	cmp	r2, r3
10001380:	d806      	bhi.n	10001390 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x54>
  {
    /* Requested IDIV is greater than currently programmed IDIV. So downscale the frequency */
    XMC_SCU_CLOCK_lFrequencyDownScaling(curr_idiv, idiv);
10001382:	68fa      	ldr	r2, [r7, #12]
10001384:	687b      	ldr	r3, [r7, #4]
10001386:	1c10      	adds	r0, r2, #0
10001388:	1c19      	adds	r1, r3, #0
1000138a:	f000 f853 	bl	10001434 <XMC_SCU_CLOCK_lFrequencyDownScaling>
1000138e:	e005      	b.n	1000139c <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x60>
  }
  else
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
10001390:	68fa      	ldr	r2, [r7, #12]
10001392:	687b      	ldr	r3, [r7, #4]
10001394:	1c10      	adds	r0, r2, #0
10001396:	1c19      	adds	r1, r3, #0
10001398:	f000 f822 	bl	100013e0 <XMC_SCU_CLOCK_lFrequencyUpScaling>
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000139c:	4b0c      	ldr	r3, [pc, #48]	; (100013d0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
1000139e:	4a0c      	ldr	r2, [pc, #48]	; (100013d0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
100013a0:	6812      	ldr	r2, [r2, #0]
100013a2:	490e      	ldr	r1, [pc, #56]	; (100013dc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xa0>)
100013a4:	4011      	ands	r1, r2
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
100013a6:	687a      	ldr	r2, [r7, #4]
100013a8:	0212      	lsls	r2, r2, #8
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100013aa:	430a      	orrs	r2, r1
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
100013ac:	490a      	ldr	r1, [pc, #40]	; (100013d8 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x9c>)
100013ae:	430a      	orrs	r2, r1
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100013b0:	601a      	str	r2, [r3, #0]
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100013b2:	46c0      	nop			; (mov r8, r8)
100013b4:	4b06      	ldr	r3, [pc, #24]	; (100013d0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x94>)
100013b6:	681a      	ldr	r2, [r3, #0]
100013b8:	2380      	movs	r3, #128	; 0x80
100013ba:	05db      	lsls	r3, r3, #23
100013bc:	4013      	ands	r3, r2
100013be:	d1f9      	bne.n	100013b4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x78>
  {
    /* Wait voltage suply stabilization */
  }

  XMC_SCU_LockProtectedBits();
100013c0:	f7ff ff60 	bl	10001284 <XMC_SCU_LockProtectedBits>

  SystemCoreClockUpdate();
100013c4:	f7ff fe72 	bl	100010ac <SystemCoreClockUpdate>

}
100013c8:	46bd      	mov	sp, r7
100013ca:	b004      	add	sp, #16
100013cc:	bd80      	pop	{r7, pc}
100013ce:	46c0      	nop			; (mov r8, r8)
100013d0:	40010300 	.word	0x40010300
100013d4:	c00fff00 	.word	0xc00fff00
100013d8:	3ff00000 	.word	0x3ff00000
100013dc:	c00f00ff 	.word	0xc00f00ff

100013e0 <XMC_SCU_CLOCK_lFrequencyUpScaling>:

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
100013e0:	b580      	push	{r7, lr}
100013e2:	b082      	sub	sp, #8
100013e4:	af00      	add	r7, sp, #0
100013e6:	6078      	str	r0, [r7, #4]
100013e8:	6039      	str	r1, [r7, #0]
  while (curr_idiv > (target_idiv * 4UL))
100013ea:	e014      	b.n	10001416 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x36>
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */
100013ec:	687b      	ldr	r3, [r7, #4]
100013ee:	089b      	lsrs	r3, r3, #2
100013f0:	607b      	str	r3, [r7, #4]

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
100013f2:	4b0d      	ldr	r3, [pc, #52]	; (10001428 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
100013f4:	4a0c      	ldr	r2, [pc, #48]	; (10001428 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
100013f6:	6812      	ldr	r2, [r2, #0]
100013f8:	490c      	ldr	r1, [pc, #48]	; (1000142c <XMC_SCU_CLOCK_lFrequencyUpScaling+0x4c>)
100013fa:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | 
100013fc:	687a      	ldr	r2, [r7, #4]
100013fe:	0212      	lsls	r2, r2, #8
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001400:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | 
10001402:	490b      	ldr	r1, [pc, #44]	; (10001430 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x50>)
10001404:	430a      	orrs	r2, r1
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001406:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | 
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001408:	46c0      	nop			; (mov r8, r8)
1000140a:	4b07      	ldr	r3, [pc, #28]	; (10001428 <XMC_SCU_CLOCK_lFrequencyUpScaling+0x48>)
1000140c:	681a      	ldr	r2, [r3, #0]
1000140e:	2380      	movs	r3, #128	; 0x80
10001410:	05db      	lsls	r3, r3, #23
10001412:	4013      	ands	r3, r2
10001414:	d1f9      	bne.n	1000140a <XMC_SCU_CLOCK_lFrequencyUpScaling+0x2a>
}

/* Utility routine to perform frequency up scaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
  while (curr_idiv > (target_idiv * 4UL))
10001416:	683b      	ldr	r3, [r7, #0]
10001418:	009a      	lsls	r2, r3, #2
1000141a:	687b      	ldr	r3, [r7, #4]
1000141c:	429a      	cmp	r2, r3
1000141e:	d3e5      	bcc.n	100013ec <XMC_SCU_CLOCK_lFrequencyUpScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
    /* Wait voltage suply stabilization */
    }
  }
}
10001420:	46bd      	mov	sp, r7
10001422:	b002      	add	sp, #8
10001424:	bd80      	pop	{r7, pc}
10001426:	46c0      	nop			; (mov r8, r8)
10001428:	40010300 	.word	0x40010300
1000142c:	c00f00ff 	.word	0xc00f00ff
10001430:	3ff00000 	.word	0x3ff00000

10001434 <XMC_SCU_CLOCK_lFrequencyDownScaling>:

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
10001434:	b580      	push	{r7, lr}
10001436:	b082      	sub	sp, #8
10001438:	af00      	add	r7, sp, #0
1000143a:	6078      	str	r0, [r7, #4]
1000143c:	6039      	str	r1, [r7, #0]

  while ((curr_idiv * 4UL) < target_idiv)
1000143e:	e019      	b.n	10001474 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x40>
  {
    if(0U == curr_idiv)
10001440:	687b      	ldr	r3, [r7, #4]
10001442:	2b00      	cmp	r3, #0
10001444:	d101      	bne.n	1000144a <XMC_SCU_CLOCK_lFrequencyDownScaling+0x16>
    {
      curr_idiv = 1U;
10001446:	2301      	movs	r3, #1
10001448:	607b      	str	r3, [r7, #4]
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
1000144a:	687b      	ldr	r3, [r7, #4]
1000144c:	009b      	lsls	r3, r3, #2
1000144e:	607b      	str	r3, [r7, #4]
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001450:	4b0c      	ldr	r3, [pc, #48]	; (10001484 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001452:	4a0c      	ldr	r2, [pc, #48]	; (10001484 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
10001454:	6812      	ldr	r2, [r2, #0]
10001456:	490c      	ldr	r1, [pc, #48]	; (10001488 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x54>)
10001458:	4011      	ands	r1, r2
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
1000145a:	687a      	ldr	r2, [r7, #4]
1000145c:	0212      	lsls	r2, r2, #8
    if(0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000145e:	430a      	orrs	r2, r1
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
10001460:	490a      	ldr	r1, [pc, #40]	; (1000148c <XMC_SCU_CLOCK_lFrequencyDownScaling+0x58>)
10001462:	430a      	orrs	r2, r1
    if(0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10001464:	601a      	str	r2, [r3, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10001466:	46c0      	nop			; (mov r8, r8)
10001468:	4b06      	ldr	r3, [pc, #24]	; (10001484 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x50>)
1000146a:	681a      	ldr	r2, [r3, #0]
1000146c:	2380      	movs	r3, #128	; 0x80
1000146e:	05db      	lsls	r3, r3, #23
10001470:	4013      	ands	r3, r2
10001472:	d1f9      	bne.n	10001468 <XMC_SCU_CLOCK_lFrequencyDownScaling+0x34>

/* Utility routine to perform frequency down scaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{

  while ((curr_idiv * 4UL) < target_idiv)
10001474:	687b      	ldr	r3, [r7, #4]
10001476:	009a      	lsls	r2, r3, #2
10001478:	683b      	ldr	r3, [r7, #0]
1000147a:	429a      	cmp	r2, r3
1000147c:	d3e0      	bcc.n	10001440 <XMC_SCU_CLOCK_lFrequencyDownScaling+0xc>
    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
    {
    /* Wait voltage suply stabilization */
    }
  }
}
1000147e:	46bd      	mov	sp, r7
10001480:	b002      	add	sp, #8
10001482:	bd80      	pop	{r7, pc}
10001484:	40010300 	.word	0x40010300
10001488:	c00f00ff 	.word	0xc00f00ff
1000148c:	3ff00000 	.word	0x3ff00000

10001490 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:

/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
10001490:	b580      	push	{r7, lr}
10001492:	af00      	add	r7, sp, #0
  return (SystemCoreClock);
10001494:	4b02      	ldr	r3, [pc, #8]	; (100014a0 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x10>)
10001496:	681b      	ldr	r3, [r3, #0]
}
10001498:	1c18      	adds	r0, r3, #0
1000149a:	46bd      	mov	sp, r7
1000149c:	bd80      	pop	{r7, pc}
1000149e:	46c0      	nop			; (mov r8, r8)
100014a0:	20003ffc 	.word	0x20003ffc

100014a4 <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
100014a4:	b580      	push	{r7, lr}
100014a6:	b082      	sub	sp, #8
100014a8:	af00      	add	r7, sp, #0
100014aa:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
100014ac:	687b      	ldr	r3, [r7, #4]
100014ae:	68db      	ldr	r3, [r3, #12]
100014b0:	2280      	movs	r2, #128	; 0x80
100014b2:	0052      	lsls	r2, r2, #1
100014b4:	431a      	orrs	r2, r3
100014b6:	687b      	ldr	r3, [r7, #4]
100014b8:	60da      	str	r2, [r3, #12]
}
100014ba:	46bd      	mov	sp, r7
100014bc:	b002      	add	sp, #8
100014be:	bd80      	pop	{r7, pc}

100014c0 <XMC_CCU4_lUngateClock>:

  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
100014c0:	b580      	push	{r7, lr}
100014c2:	b082      	sub	sp, #8
100014c4:	af00      	add	r7, sp, #0
100014c6:	6078      	str	r0, [r7, #4]
  switch ((uint32_t)module)
100014c8:	687b      	ldr	r3, [r7, #4]
100014ca:	4a05      	ldr	r2, [pc, #20]	; (100014e0 <XMC_CCU4_lUngateClock+0x20>)
100014cc:	4293      	cmp	r3, r2
100014ce:	d000      	beq.n	100014d2 <XMC_CCU4_lUngateClock+0x12>
      break;
#endif  

    default:
      XMC_ASSERT("XMC_CCU4_lUngateClock:Invalid Module Pointer", 0);
      break;   
100014d0:	e003      	b.n	100014da <XMC_CCU4_lUngateClock+0x1a>
__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  switch ((uint32_t)module)
  {
    case (uint32_t)CCU40:
      XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
100014d2:	2004      	movs	r0, #4
100014d4:	f7ff ff14 	bl	10001300 <XMC_SCU_CLOCK_UngatePeripheralClock>
      break;
100014d8:	46c0      	nop			; (mov r8, r8)
    default:
      XMC_ASSERT("XMC_CCU4_lUngateClock:Invalid Module Pointer", 0);
      break;   
    
  }
}
100014da:	46bd      	mov	sp, r7
100014dc:	b002      	add	sp, #8
100014de:	bd80      	pop	{r7, pc}
100014e0:	48040000 	.word	0x48040000

100014e4 <XMC_CCU4_EnableModule>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/

void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module)
{
100014e4:	b580      	push	{r7, lr}
100014e6:	b082      	sub	sp, #8
100014e8:	af00      	add	r7, sp, #0
100014ea:	6078      	str	r0, [r7, #4]
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
#endif
  
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU4_lUngateClock(module);
100014ec:	687b      	ldr	r3, [r7, #4]
100014ee:	1c18      	adds	r0, r3, #0
100014f0:	f7ff ffe6 	bl	100014c0 <XMC_CCU4_lUngateClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU4_lDeassertReset(module);
#endif
}
100014f4:	46bd      	mov	sp, r7
100014f6:	b002      	add	sp, #8
100014f8:	bd80      	pop	{r7, pc}
100014fa:	46c0      	nop			; (mov r8, r8)

100014fc <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
100014fc:	b580      	push	{r7, lr}
100014fe:	b084      	sub	sp, #16
10001500:	af00      	add	r7, sp, #0
10001502:	6078      	str	r0, [r7, #4]
10001504:	1c0a      	adds	r2, r1, #0
10001506:	1cfb      	adds	r3, r7, #3
10001508:	701a      	strb	r2, [r3, #0]
  
  XMC_ASSERT("XMC_CCU4_Init:Invalid module pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_Init:Invalid mcs action", XMC_CCU4_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
1000150a:	687b      	ldr	r3, [r7, #4]
1000150c:	1c18      	adds	r0, r3, #0
1000150e:	f7ff ffe9 	bl	100014e4 <XMC_CCU4_EnableModule>
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
10001512:	687b      	ldr	r3, [r7, #4]
10001514:	1c18      	adds	r0, r3, #0
10001516:	f7ff ffc5 	bl	100014a4 <XMC_CCU4_StartPrescaler>
  
  gctrl = module->GCTRL;
1000151a:	687b      	ldr	r3, [r7, #4]
1000151c:	681b      	ldr	r3, [r3, #0]
1000151e:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
10001520:	68fb      	ldr	r3, [r7, #12]
10001522:	4a07      	ldr	r2, [pc, #28]	; (10001540 <XMC_CCU4_Init+0x44>)
10001524:	4013      	ands	r3, r2
10001526:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
10001528:	1cfb      	adds	r3, r7, #3
1000152a:	781b      	ldrb	r3, [r3, #0]
1000152c:	039b      	lsls	r3, r3, #14
1000152e:	68fa      	ldr	r2, [r7, #12]
10001530:	4313      	orrs	r3, r2
10001532:	60fb      	str	r3, [r7, #12]
  
  module->GCTRL = gctrl;
10001534:	687b      	ldr	r3, [r7, #4]
10001536:	68fa      	ldr	r2, [r7, #12]
10001538:	601a      	str	r2, [r3, #0]
}
1000153a:	46bd      	mov	sp, r7
1000153c:	b004      	add	sp, #16
1000153e:	bd80      	pop	{r7, pc}
10001540:	ffff3fff 	.word	0xffff3fff

10001544 <XMC_CCU4_SLICE_CompareInit>:
}

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
		                            const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
10001544:	b580      	push	{r7, lr}
10001546:	b082      	sub	sp, #8
10001548:	af00      	add	r7, sp, #0
1000154a:	6078      	str	r0, [r7, #4]
1000154c:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
1000154e:	683b      	ldr	r3, [r7, #0]
10001550:	681a      	ldr	r2, [r3, #0]
10001552:	687b      	ldr	r3, [r7, #4]
10001554:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
10001556:	683b      	ldr	r3, [r7, #0]
10001558:	795b      	ldrb	r3, [r3, #5]
1000155a:	069b      	lsls	r3, r3, #26
1000155c:	0fdb      	lsrs	r3, r3, #31
1000155e:	b2db      	uxtb	r3, r3
10001560:	051a      	lsls	r2, r3, #20
10001562:	687b      	ldr	r3, [r7, #4]
10001564:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
10001566:	683b      	ldr	r3, [r7, #0]
10001568:	791b      	ldrb	r3, [r3, #4]
1000156a:	071b      	lsls	r3, r3, #28
1000156c:	0f1b      	lsrs	r3, r3, #28
1000156e:	b2db      	uxtb	r3, r3
10001570:	1c1a      	adds	r2, r3, #0
10001572:	687b      	ldr	r3, [r7, #4]
10001574:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
10001576:	683b      	ldr	r3, [r7, #0]
10001578:	795b      	ldrb	r3, [r3, #5]
1000157a:	071b      	lsls	r3, r3, #28
1000157c:	0f1b      	lsrs	r3, r3, #28
1000157e:	b2db      	uxtb	r3, r3
10001580:	1c1a      	adds	r2, r3, #0
10001582:	687b      	ldr	r3, [r7, #4]
10001584:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
10001586:	683b      	ldr	r3, [r7, #0]
10001588:	795b      	ldrb	r3, [r3, #5]
1000158a:	06db      	lsls	r3, r3, #27
1000158c:	0fdb      	lsrs	r3, r3, #31
1000158e:	b2db      	uxtb	r3, r3
10001590:	1c1a      	adds	r2, r3, #0
10001592:	687b      	ldr	r3, [r7, #4]
10001594:	619a      	str	r2, [r3, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
10001596:	683b      	ldr	r3, [r7, #0]
10001598:	791b      	ldrb	r3, [r3, #4]
1000159a:	061b      	lsls	r3, r3, #24
1000159c:	0f1b      	lsrs	r3, r3, #28
1000159e:	b2db      	uxtb	r3, r3
100015a0:	1c1a      	adds	r2, r3, #0
100015a2:	687b      	ldr	r3, [r7, #4]
100015a4:	62da      	str	r2, [r3, #44]	; 0x2c
}
100015a6:	46bd      	mov	sp, r7
100015a8:	b002      	add	sp, #8
100015aa:	bd80      	pop	{r7, pc}

100015ac <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
100015ac:	b580      	push	{r7, lr}
100015ae:	b086      	sub	sp, #24
100015b0:	af00      	add	r7, sp, #0
100015b2:	6078      	str	r0, [r7, #4]
100015b4:	1c08      	adds	r0, r1, #0
100015b6:	1c11      	adds	r1, r2, #0
100015b8:	1cfb      	adds	r3, r7, #3
100015ba:	1c02      	adds	r2, r0, #0
100015bc:	701a      	strb	r2, [r3, #0]
100015be:	1cbb      	adds	r3, r7, #2
100015c0:	1c0a      	adds	r2, r1, #0
100015c2:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
100015c4:	687b      	ldr	r3, [r7, #4]
100015c6:	22a8      	movs	r2, #168	; 0xa8
100015c8:	589b      	ldr	r3, [r3, r2]
100015ca:	60fb      	str	r3, [r7, #12]
  
  switch(event)
100015cc:	1cfb      	adds	r3, r7, #3
100015ce:	781b      	ldrb	r3, [r3, #0]
100015d0:	2b09      	cmp	r3, #9
100015d2:	d81a      	bhi.n	1000160a <XMC_CCU4_SLICE_SetInterruptNode+0x5e>
100015d4:	009a      	lsls	r2, r3, #2
100015d6:	4b1a      	ldr	r3, [pc, #104]	; (10001640 <XMC_CCU4_SLICE_SetInterruptNode+0x94>)
100015d8:	18d3      	adds	r3, r2, r3
100015da:	681b      	ldr	r3, [r3, #0]
100015dc:	469f      	mov	pc, r3
  {
    case XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU4_CC4_SRS_POSR_Msk);
100015de:	2303      	movs	r3, #3
100015e0:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_POSR_Pos;
100015e2:	2300      	movs	r3, #0
100015e4:	617b      	str	r3, [r7, #20]
      break;
100015e6:	e016      	b.n	10001616 <XMC_CCU4_SLICE_SetInterruptNode+0x6a>

    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP:
    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN:
      mask = ((uint32_t) CCU4_CC4_SRS_CMSR_Msk);
100015e8:	230c      	movs	r3, #12
100015ea:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_CMSR_Pos;
100015ec:	2302      	movs	r3, #2
100015ee:	617b      	str	r3, [r7, #20]
      break;
100015f0:	e011      	b.n	10001616 <XMC_CCU4_SLICE_SetInterruptNode+0x6a>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU4_CC4_SRS_E0SR_Msk);
100015f2:	23c0      	movs	r3, #192	; 0xc0
100015f4:	009b      	lsls	r3, r3, #2
100015f6:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E0SR_Pos;
100015f8:	2308      	movs	r3, #8
100015fa:	617b      	str	r3, [r7, #20]
      break;
100015fc:	e00b      	b.n	10001616 <XMC_CCU4_SLICE_SetInterruptNode+0x6a>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU4_CC4_SRS_E1SR_Msk);
100015fe:	23c0      	movs	r3, #192	; 0xc0
10001600:	011b      	lsls	r3, r3, #4
10001602:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E1SR_Pos;
10001604:	230a      	movs	r3, #10
10001606:	617b      	str	r3, [r7, #20]
      break;
10001608:	e005      	b.n	10001616 <XMC_CCU4_SLICE_SetInterruptNode+0x6a>

    default:
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
1000160a:	23c0      	movs	r3, #192	; 0xc0
1000160c:	019b      	lsls	r3, r3, #6
1000160e:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E2SR_Pos;
10001610:	230c      	movs	r3, #12
10001612:	617b      	str	r3, [r7, #20]
      break;
10001614:	46c0      	nop			; (mov r8, r8)
  }
  
  srs &= ~mask; 
10001616:	693b      	ldr	r3, [r7, #16]
10001618:	43da      	mvns	r2, r3
1000161a:	68fb      	ldr	r3, [r7, #12]
1000161c:	4013      	ands	r3, r2
1000161e:	60fb      	str	r3, [r7, #12]
  srs |= (uint32_t)sr << pos;
10001620:	1cbb      	adds	r3, r7, #2
10001622:	781a      	ldrb	r2, [r3, #0]
10001624:	697b      	ldr	r3, [r7, #20]
10001626:	409a      	lsls	r2, r3
10001628:	1c13      	adds	r3, r2, #0
1000162a:	68fa      	ldr	r2, [r7, #12]
1000162c:	4313      	orrs	r3, r2
1000162e:	60fb      	str	r3, [r7, #12]
  slice->SRS = srs;
10001630:	687b      	ldr	r3, [r7, #4]
10001632:	21a8      	movs	r1, #168	; 0xa8
10001634:	68fa      	ldr	r2, [r7, #12]
10001636:	505a      	str	r2, [r3, r1]
}
10001638:	46bd      	mov	sp, r7
1000163a:	b006      	add	sp, #24
1000163c:	bd80      	pop	{r7, pc}
1000163e:	46c0      	nop			; (mov r8, r8)
10001640:	10002c4c 	.word	0x10002c4c

10001644 <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
10001644:	b580      	push	{r7, lr}
10001646:	b082      	sub	sp, #8
10001648:	af00      	add	r7, sp, #0
1000164a:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
1000164c:	687b      	ldr	r3, [r7, #4]
1000164e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10001650:	b2db      	uxtb	r3, r3
10001652:	227f      	movs	r2, #127	; 0x7f
10001654:	4393      	bics	r3, r2
10001656:	b2db      	uxtb	r3, r3
}
10001658:	1c18      	adds	r0, r3, #0
1000165a:	46bd      	mov	sp, r7
1000165c:	b002      	add	sp, #8
1000165e:	bd80      	pop	{r7, pc}

10001660 <XMC_UART_CH_ClearStatusFlag>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_DisableEvent(),  XMC_UART_CH_GetStatusFlag()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, const uint32_t flag)
{
10001660:	b580      	push	{r7, lr}
10001662:	b082      	sub	sp, #8
10001664:	af00      	add	r7, sp, #0
10001666:	6078      	str	r0, [r7, #4]
10001668:	6039      	str	r1, [r7, #0]
  channel->PSCR = flag;
1000166a:	687b      	ldr	r3, [r7, #4]
1000166c:	683a      	ldr	r2, [r7, #0]
1000166e:	64da      	str	r2, [r3, #76]	; 0x4c
}
10001670:	46bd      	mov	sp, r7
10001672:	b002      	add	sp, #8
10001674:	bd80      	pop	{r7, pc}
10001676:	46c0      	nop			; (mov r8, r8)

10001678 <XMC_UART_CH_Init>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 *********************************************************************************************************************/

void XMC_UART_CH_Init(XMC_USIC_CH_t *channel, const XMC_UART_CH_CONFIG_t *const config)
{
10001678:	b580      	push	{r7, lr}
1000167a:	b084      	sub	sp, #16
1000167c:	af00      	add	r7, sp, #0
1000167e:	6078      	str	r0, [r7, #4]
10001680:	6039      	str	r1, [r7, #0]
  uint32_t oversampling = XMC_UART_CH_OVERSAMPLING;
10001682:	2310      	movs	r3, #16
10001684:	60fb      	str	r3, [r7, #12]

  /* USIC channel switched on*/
  XMC_USIC_CH_Enable(channel);
10001686:	687b      	ldr	r3, [r7, #4]
10001688:	1c18      	adds	r0, r3, #0
1000168a:	f000 f89d 	bl	100017c8 <XMC_USIC_CH_Enable>
  
  if(config->oversampling != 0U)
1000168e:	683b      	ldr	r3, [r7, #0]
10001690:	79db      	ldrb	r3, [r3, #7]
10001692:	2b00      	cmp	r3, #0
10001694:	d002      	beq.n	1000169c <XMC_UART_CH_Init+0x24>
  {
    oversampling = (uint32_t)config->oversampling;
10001696:	683b      	ldr	r3, [r7, #0]
10001698:	79db      	ldrb	r3, [r3, #7]
1000169a:	60fb      	str	r3, [r7, #12]
  }
  
  /* Configure baud rate */
  (void)XMC_USIC_CH_SetBaudrate(channel, config->baudrate, oversampling);
1000169c:	683b      	ldr	r3, [r7, #0]
1000169e:	681a      	ldr	r2, [r3, #0]
100016a0:	6879      	ldr	r1, [r7, #4]
100016a2:	68fb      	ldr	r3, [r7, #12]
100016a4:	1c08      	adds	r0, r1, #0
100016a6:	1c11      	adds	r1, r2, #0
100016a8:	1c1a      	adds	r2, r3, #0
100016aa:	f000 f8b5 	bl	10001818 <XMC_USIC_CH_SetBaudrate>
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision 
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
100016ae:	683b      	ldr	r3, [r7, #0]
100016b0:	799b      	ldrb	r3, [r3, #6]
100016b2:	3b01      	subs	r3, #1
100016b4:	005a      	lsls	r2, r3, #1
                                    (((oversampling >> 1UL) + 1UL) << USIC_CH_PCR_ASCMode_SP_Pos) |
100016b6:	68fb      	ldr	r3, [r7, #12]
100016b8:	085b      	lsrs	r3, r3, #1
100016ba:	3301      	adds	r3, #1
100016bc:	021b      	lsls	r3, r3, #8
   * i.e. the 0 level is signaled during the complete bit time
   * Sampling point set equal to the half of the oversampling period
   * Enable Sample Majority Decision 
   * Enable Transfer Status BUSY
   */
  channel->PCR_ASCMode = (uint32_t)(((config->stop_bits - 1UL) << USIC_CH_PCR_ASCMode_STPB_Pos) |
100016be:	4313      	orrs	r3, r2
100016c0:	4a19      	ldr	r2, [pc, #100]	; (10001728 <XMC_UART_CH_Init+0xb0>)
100016c2:	431a      	orrs	r2, r3
100016c4:	687b      	ldr	r3, [r7, #4]
100016c6:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Set passive data level, high
     Set word length. Data bits - 1
     If frame length is > 0, frame_lemgth-1; else, FLE = WLE (Data bits - 1)
     Transmission Mode: The shift control signal is considered active if it
     is at 1-level. This is the setting to be programmed to allow data transfers */
  channel->SCTR = (uint32_t)((((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_WLE_Pos) |
100016c8:	683b      	ldr	r3, [r7, #0]
100016ca:	791b      	ldrb	r3, [r3, #4]
100016cc:	3b01      	subs	r3, #1
100016ce:	061b      	lsls	r3, r3, #24
100016d0:	2281      	movs	r2, #129	; 0x81
100016d2:	0052      	lsls	r2, r2, #1
100016d4:	431a      	orrs	r2, r3
100016d6:	687b      	ldr	r3, [r7, #4]
100016d8:	635a      	str	r2, [r3, #52]	; 0x34
                             ((0x1UL << USIC_CH_SCTR_TRM_Pos) | USIC_CH_SCTR_PDL_Msk));

  if (config->frame_length != 0U)
100016da:	683b      	ldr	r3, [r7, #0]
100016dc:	795b      	ldrb	r3, [r3, #5]
100016de:	2b00      	cmp	r3, #0
100016e0:	d009      	beq.n	100016f6 <XMC_UART_CH_Init+0x7e>
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->frame_length - 1UL) << USIC_CH_SCTR_FLE_Pos);
100016e2:	687b      	ldr	r3, [r7, #4]
100016e4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
100016e6:	683b      	ldr	r3, [r7, #0]
100016e8:	795b      	ldrb	r3, [r3, #5]
100016ea:	3b01      	subs	r3, #1
100016ec:	041b      	lsls	r3, r3, #16
100016ee:	431a      	orrs	r2, r3
100016f0:	687b      	ldr	r3, [r7, #4]
100016f2:	635a      	str	r2, [r3, #52]	; 0x34
100016f4:	e008      	b.n	10001708 <XMC_UART_CH_Init+0x90>
  }
  else
  {
    channel->SCTR |= (uint32_t)(((uint32_t)config->data_bits - 1UL) << USIC_CH_SCTR_FLE_Pos);
100016f6:	687b      	ldr	r3, [r7, #4]
100016f8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
100016fa:	683b      	ldr	r3, [r7, #0]
100016fc:	791b      	ldrb	r3, [r3, #4]
100016fe:	3b01      	subs	r3, #1
10001700:	041b      	lsls	r3, r3, #16
10001702:	431a      	orrs	r2, r3
10001704:	687b      	ldr	r3, [r7, #4]
10001706:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Enable transfer buffer */
  channel->TCSR = (0x1UL << USIC_CH_TCSR_TDEN_Pos) |
10001708:	687b      	ldr	r3, [r7, #4]
1000170a:	22a0      	movs	r2, #160	; 0xa0
1000170c:	00d2      	lsls	r2, r2, #3
1000170e:	639a      	str	r2, [r3, #56]	; 0x38
                  USIC_CH_TCSR_TDSSM_Msk;

  /* Clear protocol status */
  channel->PSCR = 0xFFFFFFFFUL;
10001710:	687b      	ldr	r3, [r7, #4]
10001712:	2201      	movs	r2, #1
10001714:	4252      	negs	r2, r2
10001716:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Set parity settings */
  channel->CCR = (uint32_t)config->parity_mode;
10001718:	683b      	ldr	r3, [r7, #0]
1000171a:	891b      	ldrh	r3, [r3, #8]
1000171c:	1c1a      	adds	r2, r3, #0
1000171e:	687b      	ldr	r3, [r7, #4]
10001720:	641a      	str	r2, [r3, #64]	; 0x40
}
10001722:	46bd      	mov	sp, r7
10001724:	b004      	add	sp, #16
10001726:	bd80      	pop	{r7, pc}
10001728:	00030001 	.word	0x00030001

1000172c <XMC_UART_CH_Transmit>:
  } 
  return status;
}

void XMC_UART_CH_Transmit(XMC_USIC_CH_t *const channel, const uint16_t data)
{
1000172c:	b580      	push	{r7, lr}
1000172e:	b082      	sub	sp, #8
10001730:	af00      	add	r7, sp, #0
10001732:	6078      	str	r0, [r7, #4]
10001734:	1c0a      	adds	r2, r1, #0
10001736:	1cbb      	adds	r3, r7, #2
10001738:	801a      	strh	r2, [r3, #0]
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0UL)
1000173a:	687a      	ldr	r2, [r7, #4]
1000173c:	2384      	movs	r3, #132	; 0x84
1000173e:	005b      	lsls	r3, r3, #1
10001740:	58d2      	ldr	r2, [r2, r3]
10001742:	23e0      	movs	r3, #224	; 0xe0
10001744:	04db      	lsls	r3, r3, #19
10001746:	4013      	ands	r3, r2
10001748:	d114      	bne.n	10001774 <XMC_UART_CH_Transmit+0x48>
  {
    /* Wait till the Transmit Buffer is free for transmission */
    while(XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
1000174a:	46c0      	nop			; (mov r8, r8)
1000174c:	687b      	ldr	r3, [r7, #4]
1000174e:	1c18      	adds	r0, r3, #0
10001750:	f7ff ff78 	bl	10001644 <XMC_USIC_CH_GetTransmitBufferStatus>
10001754:	1e03      	subs	r3, r0, #0
10001756:	2b80      	cmp	r3, #128	; 0x80
10001758:	d0f8      	beq.n	1000174c <XMC_UART_CH_Transmit+0x20>
    {
    }
  
    /* Clear the Transmit Buffer indication flag */
    XMC_UART_CH_ClearStatusFlag(channel, (uint32_t)XMC_UART_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);
1000175a:	687a      	ldr	r2, [r7, #4]
1000175c:	2380      	movs	r3, #128	; 0x80
1000175e:	019b      	lsls	r3, r3, #6
10001760:	1c10      	adds	r0, r2, #0
10001762:	1c19      	adds	r1, r3, #0
10001764:	f7ff ff7c 	bl	10001660 <XMC_UART_CH_ClearStatusFlag>
  
    /*Transmit data */
    channel->TBUF[0U] = data;
10001768:	1cbb      	adds	r3, r7, #2
1000176a:	881a      	ldrh	r2, [r3, #0]
1000176c:	687b      	ldr	r3, [r7, #4]
1000176e:	2180      	movs	r1, #128	; 0x80
10001770:	505a      	str	r2, [r3, r1]
10001772:	e005      	b.n	10001780 <XMC_UART_CH_Transmit+0x54>
  }
  else
  {
    channel->IN[0U] = data;
10001774:	1cbb      	adds	r3, r7, #2
10001776:	8819      	ldrh	r1, [r3, #0]
10001778:	687a      	ldr	r2, [r7, #4]
1000177a:	23c0      	movs	r3, #192	; 0xc0
1000177c:	005b      	lsls	r3, r3, #1
1000177e:	50d1      	str	r1, [r2, r3]
  }
}
10001780:	46bd      	mov	sp, r7
10001782:	b002      	add	sp, #8
10001784:	bd80      	pop	{r7, pc}
10001786:	46c0      	nop			; (mov r8, r8)

10001788 <XMC_UART_CH_GetReceivedData>:

uint16_t XMC_UART_CH_GetReceivedData(XMC_USIC_CH_t *const channel)
{
10001788:	b580      	push	{r7, lr}
1000178a:	b084      	sub	sp, #16
1000178c:	af00      	add	r7, sp, #0
1000178e:	6078      	str	r0, [r7, #4]
  uint16_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
10001790:	687a      	ldr	r2, [r7, #4]
10001792:	2386      	movs	r3, #134	; 0x86
10001794:	005b      	lsls	r3, r3, #1
10001796:	58d2      	ldr	r2, [r2, r3]
10001798:	23e0      	movs	r3, #224	; 0xe0
1000179a:	04db      	lsls	r3, r3, #19
1000179c:	4013      	ands	r3, r2
1000179e:	d105      	bne.n	100017ac <XMC_UART_CH_GetReceivedData+0x24>
  {
    retval = (uint16_t)channel->RBUF;
100017a0:	687b      	ldr	r3, [r7, #4]
100017a2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
100017a4:	230e      	movs	r3, #14
100017a6:	18fb      	adds	r3, r7, r3
100017a8:	801a      	strh	r2, [r3, #0]
100017aa:	e006      	b.n	100017ba <XMC_UART_CH_GetReceivedData+0x32>
  }
  else
  {
    retval = (uint16_t)channel->OUTR;
100017ac:	687a      	ldr	r2, [r7, #4]
100017ae:	238e      	movs	r3, #142	; 0x8e
100017b0:	005b      	lsls	r3, r3, #1
100017b2:	58d2      	ldr	r2, [r2, r3]
100017b4:	230e      	movs	r3, #14
100017b6:	18fb      	adds	r3, r7, r3
100017b8:	801a      	strh	r2, [r3, #0]
  }

  return retval;
100017ba:	230e      	movs	r3, #14
100017bc:	18fb      	adds	r3, r7, r3
100017be:	881b      	ldrh	r3, [r3, #0]
}
100017c0:	1c18      	adds	r0, r3, #0
100017c2:	46bd      	mov	sp, r7
100017c4:	b004      	add	sp, #16
100017c6:	bd80      	pop	{r7, pc}

100017c8 <XMC_USIC_CH_Enable>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
100017c8:	b580      	push	{r7, lr}
100017ca:	b082      	sub	sp, #8
100017cc:	af00      	add	r7, sp, #0
100017ce:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
100017d0:	687a      	ldr	r2, [r7, #4]
100017d2:	2390      	movs	r3, #144	; 0x90
100017d4:	05db      	lsls	r3, r3, #23
100017d6:	429a      	cmp	r2, r3
100017d8:	d003      	beq.n	100017e2 <XMC_USIC_CH_Enable+0x1a>
100017da:	687b      	ldr	r3, [r7, #4]
100017dc:	4a0c      	ldr	r2, [pc, #48]	; (10001810 <XMC_USIC_CH_Enable+0x48>)
100017de:	4293      	cmp	r3, r2
100017e0:	d103      	bne.n	100017ea <XMC_USIC_CH_Enable+0x22>
  {
    XMC_USIC_Enable(XMC_USIC0);
100017e2:	4b0c      	ldr	r3, [pc, #48]	; (10001814 <XMC_USIC_CH_Enable+0x4c>)
100017e4:	1c18      	adds	r0, r3, #0
100017e6:	f000 f983 	bl	10001af0 <XMC_USIC_Enable>
  {
    XMC_ASSERT("USIC module not available", 0U/*Always*/);
  }

  /* USIC channel switched on*/
  channel->KSCFG = (USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk);
100017ea:	687b      	ldr	r3, [r7, #4]
100017ec:	2203      	movs	r2, #3
100017ee:	60da      	str	r2, [r3, #12]
  while ((channel->KSCFG & USIC_CH_KSCFG_MODEN_Msk) == 0U)
100017f0:	46c0      	nop			; (mov r8, r8)
100017f2:	687b      	ldr	r3, [r7, #4]
100017f4:	68db      	ldr	r3, [r3, #12]
100017f6:	2201      	movs	r2, #1
100017f8:	4013      	ands	r3, r2
100017fa:	d0fa      	beq.n	100017f2 <XMC_USIC_CH_Enable+0x2a>
  {
    /* Wait till the channel is enabled */
  }

  /* Set USIC channel in IDLE mode */
  channel->CCR &= (uint32_t)~USIC_CH_CCR_MODE_Msk;
100017fc:	687b      	ldr	r3, [r7, #4]
100017fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10001800:	220f      	movs	r2, #15
10001802:	4393      	bics	r3, r2
10001804:	1c1a      	adds	r2, r3, #0
10001806:	687b      	ldr	r3, [r7, #4]
10001808:	641a      	str	r2, [r3, #64]	; 0x40
}
1000180a:	46bd      	mov	sp, r7
1000180c:	b002      	add	sp, #8
1000180e:	bd80      	pop	{r7, pc}
10001810:	48000200 	.word	0x48000200
10001814:	48000008 	.word	0x48000008

10001818 <XMC_USIC_CH_SetBaudrate>:
{
  channel->KSCFG = (uint32_t)((channel->KSCFG & (~USIC_CH_KSCFG_MODEN_Msk)) | USIC_CH_KSCFG_BPMODEN_Msk);
}

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
10001818:	b580      	push	{r7, lr}
1000181a:	b08e      	sub	sp, #56	; 0x38
1000181c:	af00      	add	r7, sp, #0
1000181e:	60f8      	str	r0, [r7, #12]
10001820:	60b9      	str	r1, [r7, #8]
10001822:	607a      	str	r2, [r7, #4]
  
  uint32_t pdiv_frac;
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
10001824:	68bb      	ldr	r3, [r7, #8]
10001826:	2b63      	cmp	r3, #99	; 0x63
10001828:	d95c      	bls.n	100018e4 <XMC_USIC_CH_SetBaudrate+0xcc>
1000182a:	687b      	ldr	r3, [r7, #4]
1000182c:	2b00      	cmp	r3, #0
1000182e:	d059      	beq.n	100018e4 <XMC_USIC_CH_SetBaudrate+0xcc>
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
10001830:	f7ff fe2e 	bl	10001490 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
10001834:	1c03      	adds	r3, r0, #0
10001836:	1c18      	adds	r0, r3, #0
10001838:	2164      	movs	r1, #100	; 0x64
1000183a:	f001 f94f 	bl	10002adc <__aeabi_uidiv>
1000183e:	1c03      	adds	r3, r0, #0
10001840:	623b      	str	r3, [r7, #32]
    rate = rate / 100U;
10001842:	68bb      	ldr	r3, [r7, #8]
10001844:	1c18      	adds	r0, r3, #0
10001846:	2164      	movs	r1, #100	; 0x64
10001848:	f001 f948 	bl	10002adc <__aeabi_uidiv>
1000184c:	1c03      	adds	r3, r0, #0
1000184e:	60bb      	str	r3, [r7, #8]

    clock_divider_min = 1U;
10001850:	2301      	movs	r3, #1
10001852:	62fb      	str	r3, [r7, #44]	; 0x2c
    pdiv_int_min = 1U;
10001854:	2301      	movs	r3, #1
10001856:	62bb      	str	r3, [r7, #40]	; 0x28
    pdiv_frac_min = 0x3ffU;
10001858:	4b28      	ldr	r3, [pc, #160]	; (100018fc <XMC_USIC_CH_SetBaudrate+0xe4>)
1000185a:	627b      	str	r3, [r7, #36]	; 0x24

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
1000185c:	4b27      	ldr	r3, [pc, #156]	; (100018fc <XMC_USIC_CH_SetBaudrate+0xe4>)
1000185e:	633b      	str	r3, [r7, #48]	; 0x30
10001860:	e024      	b.n	100018ac <XMC_USIC_CH_SetBaudrate+0x94>
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
10001862:	6a3b      	ldr	r3, [r7, #32]
10001864:	6b3a      	ldr	r2, [r7, #48]	; 0x30
10001866:	435a      	muls	r2, r3
10001868:	1c11      	adds	r1, r2, #0
1000186a:	68bb      	ldr	r3, [r7, #8]
1000186c:	687a      	ldr	r2, [r7, #4]
1000186e:	4353      	muls	r3, r2
10001870:	1c08      	adds	r0, r1, #0
10001872:	1c19      	adds	r1, r3, #0
10001874:	f001 f932 	bl	10002adc <__aeabi_uidiv>
10001878:	1c03      	adds	r3, r0, #0
1000187a:	61fb      	str	r3, [r7, #28]
      pdiv_int = pdiv >> 10U;
1000187c:	69fb      	ldr	r3, [r7, #28]
1000187e:	0a9b      	lsrs	r3, r3, #10
10001880:	61bb      	str	r3, [r7, #24]
      pdiv_frac = pdiv & 0x3ffU;
10001882:	69fb      	ldr	r3, [r7, #28]
10001884:	059b      	lsls	r3, r3, #22
10001886:	0d9b      	lsrs	r3, r3, #22
10001888:	617b      	str	r3, [r7, #20]

      if ((pdiv_int < 1024U) && (pdiv_frac < pdiv_frac_min))
1000188a:	69bb      	ldr	r3, [r7, #24]
1000188c:	4a1b      	ldr	r2, [pc, #108]	; (100018fc <XMC_USIC_CH_SetBaudrate+0xe4>)
1000188e:	4293      	cmp	r3, r2
10001890:	d809      	bhi.n	100018a6 <XMC_USIC_CH_SetBaudrate+0x8e>
10001892:	697a      	ldr	r2, [r7, #20]
10001894:	6a7b      	ldr	r3, [r7, #36]	; 0x24
10001896:	429a      	cmp	r2, r3
10001898:	d205      	bcs.n	100018a6 <XMC_USIC_CH_SetBaudrate+0x8e>
      {
        pdiv_frac_min = pdiv_frac;
1000189a:	697b      	ldr	r3, [r7, #20]
1000189c:	627b      	str	r3, [r7, #36]	; 0x24
        pdiv_int_min = pdiv_int;
1000189e:	69bb      	ldr	r3, [r7, #24]
100018a0:	62bb      	str	r3, [r7, #40]	; 0x28
        clock_divider_min = clock_divider;
100018a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
100018a4:	62fb      	str	r3, [r7, #44]	; 0x2c

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
100018a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
100018a8:	3b01      	subs	r3, #1
100018aa:	633b      	str	r3, [r7, #48]	; 0x30
100018ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
100018ae:	2b00      	cmp	r3, #0
100018b0:	d1d7      	bne.n	10001862 <XMC_USIC_CH_SetBaudrate+0x4a>
        pdiv_int_min = pdiv_int;
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
100018b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
100018b4:	2280      	movs	r2, #128	; 0x80
100018b6:	0212      	lsls	r2, r2, #8
100018b8:	431a      	orrs	r2, r3
100018ba:	68fb      	ldr	r3, [r7, #12]
100018bc:	611a      	str	r2, [r3, #16]
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
100018be:	68fb      	ldr	r3, [r7, #12]
100018c0:	695b      	ldr	r3, [r3, #20]
100018c2:	4a0f      	ldr	r2, [pc, #60]	; (10001900 <XMC_USIC_CH_SetBaudrate+0xe8>)
100018c4:	401a      	ands	r2, r3
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
100018c6:	687b      	ldr	r3, [r7, #4]
100018c8:	3b01      	subs	r3, #1
100018ca:	029b      	lsls	r3, r3, #10
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
100018cc:	431a      	orrs	r2, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
100018ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
100018d0:	3b01      	subs	r3, #1
100018d2:	041b      	lsls	r3, r3, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
100018d4:	431a      	orrs	r2, r3
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
100018d6:	68fb      	ldr	r3, [r7, #12]
100018d8:	615a      	str	r2, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
                    
    status = XMC_USIC_CH_STATUS_OK;
100018da:	2337      	movs	r3, #55	; 0x37
100018dc:	18fb      	adds	r3, r7, r3
100018de:	2200      	movs	r2, #0
100018e0:	701a      	strb	r2, [r3, #0]
100018e2:	e003      	b.n	100018ec <XMC_USIC_CH_SetBaudrate+0xd4>
  }
  else 
  {
    status = XMC_USIC_CH_STATUS_ERROR;
100018e4:	2337      	movs	r3, #55	; 0x37
100018e6:	18fb      	adds	r3, r7, r3
100018e8:	2201      	movs	r2, #1
100018ea:	701a      	strb	r2, [r3, #0]
  }
  
  return status;
100018ec:	2337      	movs	r3, #55	; 0x37
100018ee:	18fb      	adds	r3, r7, r3
100018f0:	781b      	ldrb	r3, [r3, #0]
}
100018f2:	1c18      	adds	r0, r3, #0
100018f4:	46bd      	mov	sp, r7
100018f6:	b00e      	add	sp, #56	; 0x38
100018f8:	bd80      	pop	{r7, pc}
100018fa:	46c0      	nop			; (mov r8, r8)
100018fc:	000003ff 	.word	0x000003ff
10001900:	fc0080ef 	.word	0xfc0080ef

10001904 <XMC_USIC_CH_TXFIFO_Configure>:

void XMC_USIC_CH_TXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
10001904:	b580      	push	{r7, lr}
10001906:	b084      	sub	sp, #16
10001908:	af00      	add	r7, sp, #0
1000190a:	60f8      	str	r0, [r7, #12]
1000190c:	60b9      	str	r1, [r7, #8]
1000190e:	603b      	str	r3, [r7, #0]
10001910:	1dfb      	adds	r3, r7, #7
10001912:	701a      	strb	r2, [r3, #0]
  /* Disable FIFO */
  channel->TBCTR &= (uint32_t)~USIC_CH_TBCTR_SIZE_Msk;
10001914:	68fa      	ldr	r2, [r7, #12]
10001916:	2384      	movs	r3, #132	; 0x84
10001918:	005b      	lsls	r3, r3, #1
1000191a:	58d3      	ldr	r3, [r2, r3]
1000191c:	4a0e      	ldr	r2, [pc, #56]	; (10001958 <XMC_USIC_CH_TXFIFO_Configure+0x54>)
1000191e:	4013      	ands	r3, r2
10001920:	1c19      	adds	r1, r3, #0
10001922:	68fa      	ldr	r2, [r7, #12]
10001924:	2384      	movs	r3, #132	; 0x84
10001926:	005b      	lsls	r3, r3, #1
10001928:	50d1      	str	r1, [r2, r3]
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
1000192a:	68fa      	ldr	r2, [r7, #12]
1000192c:	2384      	movs	r3, #132	; 0x84
1000192e:	005b      	lsls	r3, r3, #1
10001930:	58d3      	ldr	r3, [r2, r3]
10001932:	4a0a      	ldr	r2, [pc, #40]	; (1000195c <XMC_USIC_CH_TXFIFO_Configure+0x58>)
10001934:	401a      	ands	r2, r3
                                                           USIC_CH_TBCTR_DPTR_Msk |
                                                           USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
10001936:	683b      	ldr	r3, [r7, #0]
10001938:	0219      	lsls	r1, r3, #8
1000193a:	68bb      	ldr	r3, [r7, #8]
1000193c:	4319      	orrs	r1, r3
                   (data_pointer << USIC_CH_TBCTR_DPTR_Pos) |
                   ((uint32_t)size << USIC_CH_TBCTR_SIZE_Pos));
1000193e:	1dfb      	adds	r3, r7, #7
10001940:	781b      	ldrb	r3, [r3, #0]
10001942:	061b      	lsls	r3, r3, #24
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
                                                           USIC_CH_TBCTR_DPTR_Msk |
                                                           USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
10001944:	430b      	orrs	r3, r1
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
                                                           USIC_CH_TBCTR_DPTR_Msk |
                                                           USIC_CH_TBCTR_SIZE_Msk)) |
10001946:	431a      	orrs	r2, r3
10001948:	1c11      	adds	r1, r2, #0
  /* LOF = 0, A standard transmit buffer event occurs when the filling level equals the limit value and gets
   * lower due to transmission of a data word
   * STBTEN = 0, the trigger of the standard transmit buffer event is based on the transition of the fill level
   *  from equal to below the limit, not the fact being below
   */
  channel->TBCTR = (uint32_t)(channel->TBCTR & (uint32_t)~(USIC_CH_TBCTR_LIMIT_Msk |
1000194a:	68fa      	ldr	r2, [r7, #12]
1000194c:	2384      	movs	r3, #132	; 0x84
1000194e:	005b      	lsls	r3, r3, #1
10001950:	50d1      	str	r1, [r2, r3]
                                                           USIC_CH_TBCTR_DPTR_Msk |
                                                           USIC_CH_TBCTR_SIZE_Msk)) |
                   (uint32_t)((limit << USIC_CH_TBCTR_LIMIT_Pos) |
                   (data_pointer << USIC_CH_TBCTR_DPTR_Pos) |
                   ((uint32_t)size << USIC_CH_TBCTR_SIZE_Pos));
}
10001952:	46bd      	mov	sp, r7
10001954:	b004      	add	sp, #16
10001956:	bd80      	pop	{r7, pc}
10001958:	f8ffffff 	.word	0xf8ffffff
1000195c:	f8ffc0c0 	.word	0xf8ffc0c0

10001960 <XMC_USIC_CH_RXFIFO_Configure>:

void XMC_USIC_CH_RXFIFO_Configure(XMC_USIC_CH_t *const channel,
                                  const uint32_t data_pointer,
                                  const XMC_USIC_CH_FIFO_SIZE_t size,
                                  const uint32_t limit)
{
10001960:	b580      	push	{r7, lr}
10001962:	b084      	sub	sp, #16
10001964:	af00      	add	r7, sp, #0
10001966:	60f8      	str	r0, [r7, #12]
10001968:	60b9      	str	r1, [r7, #8]
1000196a:	603b      	str	r3, [r7, #0]
1000196c:	1dfb      	adds	r3, r7, #7
1000196e:	701a      	strb	r2, [r3, #0]
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;
10001970:	68fa      	ldr	r2, [r7, #12]
10001972:	2386      	movs	r3, #134	; 0x86
10001974:	005b      	lsls	r3, r3, #1
10001976:	58d3      	ldr	r3, [r2, r3]
10001978:	4a10      	ldr	r2, [pc, #64]	; (100019bc <XMC_USIC_CH_RXFIFO_Configure+0x5c>)
1000197a:	4013      	ands	r3, r2
1000197c:	1c19      	adds	r1, r3, #0
1000197e:	68fa      	ldr	r2, [r7, #12]
10001980:	2386      	movs	r3, #134	; 0x86
10001982:	005b      	lsls	r3, r3, #1
10001984:	50d1      	str	r1, [r2, r3]

  /* LOF = 1, A standard receive buffer event occurs when the filling level equals the limit value and gets bigger
   *  due to the reception of a new data word
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
10001986:	68fa      	ldr	r2, [r7, #12]
10001988:	2386      	movs	r3, #134	; 0x86
1000198a:	005b      	lsls	r3, r3, #1
1000198c:	58d3      	ldr	r3, [r2, r3]
1000198e:	4a0c      	ldr	r2, [pc, #48]	; (100019c0 <XMC_USIC_CH_RXFIFO_Configure+0x60>)
10001990:	401a      	ands	r2, r3
                                                            USIC_CH_RBCTR_DPTR_Msk |
                                                            USIC_CH_RBCTR_LOF_Msk)) |
                   ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
10001992:	683b      	ldr	r3, [r7, #0]
10001994:	0219      	lsls	r1, r3, #8
10001996:	68bb      	ldr	r3, [r7, #8]
10001998:	4319      	orrs	r1, r3
                   (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
                   ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos) |
1000199a:	1dfb      	adds	r3, r7, #7
1000199c:	781b      	ldrb	r3, [r3, #0]
1000199e:	061b      	lsls	r3, r3, #24
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
                                                            USIC_CH_RBCTR_DPTR_Msk |
                                                            USIC_CH_RBCTR_LOF_Msk)) |
                   ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
                   (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
100019a0:	430b      	orrs	r3, r1
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;

  /* LOF = 1, A standard receive buffer event occurs when the filling level equals the limit value and gets bigger
   *  due to the reception of a new data word
   */
  channel->RBCTR = (uint32_t)((channel->RBCTR & (uint32_t)~(USIC_CH_RBCTR_LIMIT_Msk |
100019a2:	4313      	orrs	r3, r2
100019a4:	2280      	movs	r2, #128	; 0x80
100019a6:	0552      	lsls	r2, r2, #21
100019a8:	431a      	orrs	r2, r3
100019aa:	1c11      	adds	r1, r2, #0
100019ac:	68fa      	ldr	r2, [r7, #12]
100019ae:	2386      	movs	r3, #134	; 0x86
100019b0:	005b      	lsls	r3, r3, #1
100019b2:	50d1      	str	r1, [r2, r3]
                                                            USIC_CH_RBCTR_LOF_Msk)) |
                   ((limit << USIC_CH_RBCTR_LIMIT_Pos) |
                   (data_pointer << USIC_CH_RBCTR_DPTR_Pos) |
                   ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos) |
                   (uint32_t)USIC_CH_RBCTR_LOF_Msk));
}
100019b4:	46bd      	mov	sp, r7
100019b6:	b004      	add	sp, #16
100019b8:	bd80      	pop	{r7, pc}
100019ba:	46c0      	nop			; (mov r8, r8)
100019bc:	f8ffffff 	.word	0xf8ffffff
100019c0:	efffc0c0 	.word	0xefffc0c0

100019c4 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>:
}

void XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(XMC_USIC_CH_t *const channel,
                                            const XMC_USIC_CH_FIFO_SIZE_t size,
                                            const uint32_t limit)
{
100019c4:	b580      	push	{r7, lr}
100019c6:	b084      	sub	sp, #16
100019c8:	af00      	add	r7, sp, #0
100019ca:	60f8      	str	r0, [r7, #12]
100019cc:	607a      	str	r2, [r7, #4]
100019ce:	230b      	movs	r3, #11
100019d0:	18fb      	adds	r3, r7, r3
100019d2:	1c0a      	adds	r2, r1, #0
100019d4:	701a      	strb	r2, [r3, #0]
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;
100019d6:	68fa      	ldr	r2, [r7, #12]
100019d8:	2386      	movs	r3, #134	; 0x86
100019da:	005b      	lsls	r3, r3, #1
100019dc:	58d3      	ldr	r3, [r2, r3]
100019de:	4a0e      	ldr	r2, [pc, #56]	; (10001a18 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit+0x54>)
100019e0:	4013      	ands	r3, r2
100019e2:	1c19      	adds	r1, r3, #0
100019e4:	68fa      	ldr	r2, [r7, #12]
100019e6:	2386      	movs	r3, #134	; 0x86
100019e8:	005b      	lsls	r3, r3, #1
100019ea:	50d1      	str	r1, [r2, r3]

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
100019ec:	68fa      	ldr	r2, [r7, #12]
100019ee:	2386      	movs	r3, #134	; 0x86
100019f0:	005b      	lsls	r3, r3, #1
100019f2:	58d3      	ldr	r3, [r2, r3]
100019f4:	4a09      	ldr	r2, [pc, #36]	; (10001a1c <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit+0x58>)
100019f6:	401a      	ands	r2, r3
                   (limit << USIC_CH_RBCTR_LIMIT_Pos) |
100019f8:	687b      	ldr	r3, [r7, #4]
100019fa:	021b      	lsls	r3, r3, #8
                                            const uint32_t limit)
{
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
100019fc:	431a      	orrs	r2, r3
                   (limit << USIC_CH_RBCTR_LIMIT_Pos) |
                   ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos));
100019fe:	230b      	movs	r3, #11
10001a00:	18fb      	adds	r3, r7, r3
10001a02:	781b      	ldrb	r3, [r3, #0]
10001a04:	061b      	lsls	r3, r3, #24
                                            const uint32_t limit)
{
  /* Disable FIFO */
  channel->RBCTR &= (uint32_t)~USIC_CH_RBCTR_SIZE_Msk;

  channel->RBCTR = (uint32_t)((uint32_t)(channel->RBCTR & (uint32_t)~USIC_CH_RBCTR_LIMIT_Msk) |
10001a06:	431a      	orrs	r2, r3
10001a08:	1c11      	adds	r1, r2, #0
10001a0a:	68fa      	ldr	r2, [r7, #12]
10001a0c:	2386      	movs	r3, #134	; 0x86
10001a0e:	005b      	lsls	r3, r3, #1
10001a10:	50d1      	str	r1, [r2, r3]
                   (limit << USIC_CH_RBCTR_LIMIT_Pos) |
                   ((uint32_t)size << USIC_CH_RBCTR_SIZE_Pos));
}
10001a12:	46bd      	mov	sp, r7
10001a14:	b004      	add	sp, #16
10001a16:	bd80      	pop	{r7, pc}
10001a18:	f8ffffff 	.word	0xf8ffffff
10001a1c:	ffffc0ff 	.word	0xffffc0ff

10001a20 <XMC_USIC_CH_SetInterruptNodePointer>:

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                         const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
                                         const uint32_t service_request)
{
10001a20:	b580      	push	{r7, lr}
10001a22:	b084      	sub	sp, #16
10001a24:	af00      	add	r7, sp, #0
10001a26:	60f8      	str	r0, [r7, #12]
10001a28:	607a      	str	r2, [r7, #4]
10001a2a:	230b      	movs	r3, #11
10001a2c:	18fb      	adds	r3, r7, r3
10001a2e:	1c0a      	adds	r2, r1, #0
10001a30:	701a      	strb	r2, [r3, #0]
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001a32:	68fb      	ldr	r3, [r7, #12]
10001a34:	699b      	ldr	r3, [r3, #24]
10001a36:	220b      	movs	r2, #11
10001a38:	18ba      	adds	r2, r7, r2
10001a3a:	7812      	ldrb	r2, [r2, #0]
10001a3c:	2107      	movs	r1, #7
10001a3e:	4091      	lsls	r1, r2
10001a40:	1c0a      	adds	r2, r1, #0
10001a42:	43d2      	mvns	r2, r2
10001a44:	401a      	ands	r2, r3
                  (service_request << (uint32_t)interrupt_node));
10001a46:	230b      	movs	r3, #11
10001a48:	18fb      	adds	r3, r7, r3
10001a4a:	781b      	ldrb	r3, [r3, #0]
10001a4c:	6879      	ldr	r1, [r7, #4]
10001a4e:	4099      	lsls	r1, r3
10001a50:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                         const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
                                         const uint32_t service_request)
{
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001a52:	431a      	orrs	r2, r3
10001a54:	68fb      	ldr	r3, [r7, #12]
10001a56:	619a      	str	r2, [r3, #24]
                  (service_request << (uint32_t)interrupt_node));
}
10001a58:	46bd      	mov	sp, r7
10001a5a:	b004      	add	sp, #16
10001a5c:	bd80      	pop	{r7, pc}
10001a5e:	46c0      	nop			; (mov r8, r8)

10001a60 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>:

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                                const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
                                                const uint32_t service_request)
{
10001a60:	b580      	push	{r7, lr}
10001a62:	b084      	sub	sp, #16
10001a64:	af00      	add	r7, sp, #0
10001a66:	60f8      	str	r0, [r7, #12]
10001a68:	607a      	str	r2, [r7, #4]
10001a6a:	230b      	movs	r3, #11
10001a6c:	18fb      	adds	r3, r7, r3
10001a6e:	1c0a      	adds	r2, r1, #0
10001a70:	701a      	strb	r2, [r3, #0]
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001a72:	68fa      	ldr	r2, [r7, #12]
10001a74:	2384      	movs	r3, #132	; 0x84
10001a76:	005b      	lsls	r3, r3, #1
10001a78:	58d3      	ldr	r3, [r2, r3]
10001a7a:	220b      	movs	r2, #11
10001a7c:	18ba      	adds	r2, r7, r2
10001a7e:	7812      	ldrb	r2, [r2, #0]
10001a80:	2107      	movs	r1, #7
10001a82:	4091      	lsls	r1, r2
10001a84:	1c0a      	adds	r2, r1, #0
10001a86:	43d2      	mvns	r2, r2
10001a88:	401a      	ands	r2, r3
                   (service_request << (uint32_t)interrupt_node));
10001a8a:	230b      	movs	r3, #11
10001a8c:	18fb      	adds	r3, r7, r3
10001a8e:	781b      	ldrb	r3, [r3, #0]
10001a90:	6879      	ldr	r1, [r7, #4]
10001a92:	4099      	lsls	r1, r3
10001a94:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                                const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
                                                const uint32_t service_request)
{
  channel->TBCTR = (uint32_t)((channel->TBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001a96:	431a      	orrs	r2, r3
10001a98:	1c11      	adds	r1, r2, #0
10001a9a:	68fa      	ldr	r2, [r7, #12]
10001a9c:	2384      	movs	r3, #132	; 0x84
10001a9e:	005b      	lsls	r3, r3, #1
10001aa0:	50d1      	str	r1, [r2, r3]
                   (service_request << (uint32_t)interrupt_node));
}
10001aa2:	46bd      	mov	sp, r7
10001aa4:	b004      	add	sp, #16
10001aa6:	bd80      	pop	{r7, pc}

10001aa8 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>:

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                                const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
                                                const uint32_t service_request)
{
10001aa8:	b580      	push	{r7, lr}
10001aaa:	b084      	sub	sp, #16
10001aac:	af00      	add	r7, sp, #0
10001aae:	60f8      	str	r0, [r7, #12]
10001ab0:	607a      	str	r2, [r7, #4]
10001ab2:	230b      	movs	r3, #11
10001ab4:	18fb      	adds	r3, r7, r3
10001ab6:	1c0a      	adds	r2, r1, #0
10001ab8:	701a      	strb	r2, [r3, #0]
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001aba:	68fa      	ldr	r2, [r7, #12]
10001abc:	2386      	movs	r3, #134	; 0x86
10001abe:	005b      	lsls	r3, r3, #1
10001ac0:	58d3      	ldr	r3, [r2, r3]
10001ac2:	220b      	movs	r2, #11
10001ac4:	18ba      	adds	r2, r7, r2
10001ac6:	7812      	ldrb	r2, [r2, #0]
10001ac8:	2107      	movs	r1, #7
10001aca:	4091      	lsls	r1, r2
10001acc:	1c0a      	adds	r2, r1, #0
10001ace:	43d2      	mvns	r2, r2
10001ad0:	401a      	ands	r2, r3
                   (service_request << (uint32_t)interrupt_node));
10001ad2:	230b      	movs	r3, #11
10001ad4:	18fb      	adds	r3, r7, r3
10001ad6:	781b      	ldrb	r3, [r3, #0]
10001ad8:	6879      	ldr	r1, [r7, #4]
10001ada:	4099      	lsls	r1, r3
10001adc:	1c0b      	adds	r3, r1, #0

void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
                                                const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t interrupt_node,
                                                const uint32_t service_request)
{
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
10001ade:	431a      	orrs	r2, r3
10001ae0:	1c11      	adds	r1, r2, #0
10001ae2:	68fa      	ldr	r2, [r7, #12]
10001ae4:	2386      	movs	r3, #134	; 0x86
10001ae6:	005b      	lsls	r3, r3, #1
10001ae8:	50d1      	str	r1, [r2, r3]
                   (service_request << (uint32_t)interrupt_node));
}
10001aea:	46bd      	mov	sp, r7
10001aec:	b004      	add	sp, #16
10001aee:	bd80      	pop	{r7, pc}

10001af0 <XMC_USIC_Enable>:

void XMC_USIC_Enable(XMC_USIC_t *const usic)
{
10001af0:	b580      	push	{r7, lr}
10001af2:	b082      	sub	sp, #8
10001af4:	af00      	add	r7, sp, #0
10001af6:	6078      	str	r0, [r7, #4]
  if (usic == USIC0)
10001af8:	687b      	ldr	r3, [r7, #4]
10001afa:	4a04      	ldr	r2, [pc, #16]	; (10001b0c <XMC_USIC_Enable+0x1c>)
10001afc:	4293      	cmp	r3, r2
10001afe:	d102      	bne.n	10001b06 <XMC_USIC_Enable+0x16>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC0);
10001b00:	2008      	movs	r0, #8
10001b02:	f7ff fbfd 	bl	10001300 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif  
  else
  {
    XMC_ASSERT("USIC module not available", 0/*Always*/);
  }
}
10001b06:	46bd      	mov	sp, r7
10001b08:	b002      	add	sp, #8
10001b0a:	bd80      	pop	{r7, pc}
10001b0c:	48000008 	.word	0x48000008

10001b10 <_init>:
  }
}

/* Init */
void _init(void)
{}
10001b10:	b580      	push	{r7, lr}
10001b12:	af00      	add	r7, sp, #0
10001b14:	46bd      	mov	sp, r7
10001b16:	bd80      	pop	{r7, pc}

10001b18 <XMC_USIC_CH_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001b18:	b580      	push	{r7, lr}
10001b1a:	b082      	sub	sp, #8
10001b1c:	af00      	add	r7, sp, #0
10001b1e:	6078      	str	r0, [r7, #4]
10001b20:	6039      	str	r1, [r7, #0]
  channel->CCR |= event;
10001b22:	687b      	ldr	r3, [r7, #4]
10001b24:	6c1a      	ldr	r2, [r3, #64]	; 0x40
10001b26:	683b      	ldr	r3, [r7, #0]
10001b28:	431a      	orrs	r2, r3
10001b2a:	687b      	ldr	r3, [r7, #4]
10001b2c:	641a      	str	r2, [r3, #64]	; 0x40
}
10001b2e:	46bd      	mov	sp, r7
10001b30:	b002      	add	sp, #8
10001b32:	bd80      	pop	{r7, pc}

10001b34 <XMC_USIC_CH_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
*/
__STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001b34:	b580      	push	{r7, lr}
10001b36:	b082      	sub	sp, #8
10001b38:	af00      	add	r7, sp, #0
10001b3a:	6078      	str	r0, [r7, #4]
10001b3c:	6039      	str	r1, [r7, #0]
  channel->CCR &= (uint32_t)~event;
10001b3e:	687b      	ldr	r3, [r7, #4]
10001b40:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10001b42:	683a      	ldr	r2, [r7, #0]
10001b44:	43d2      	mvns	r2, r2
10001b46:	401a      	ands	r2, r3
10001b48:	687b      	ldr	r3, [r7, #4]
10001b4a:	641a      	str	r2, [r3, #64]	; 0x40
}
10001b4c:	46bd      	mov	sp, r7
10001b4e:	b002      	add	sp, #8
10001b50:	bd80      	pop	{r7, pc}
10001b52:	46c0      	nop			; (mov r8, r8)

10001b54 <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
10001b54:	b580      	push	{r7, lr}
10001b56:	b082      	sub	sp, #8
10001b58:	af00      	add	r7, sp, #0
10001b5a:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
10001b5c:	687b      	ldr	r3, [r7, #4]
10001b5e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
10001b60:	b2db      	uxtb	r3, r3
10001b62:	227f      	movs	r2, #127	; 0x7f
10001b64:	4393      	bics	r3, r2
10001b66:	b2db      	uxtb	r3, r3
}
10001b68:	1c18      	adds	r0, r3, #0
10001b6a:	46bd      	mov	sp, r7
10001b6c:	b002      	add	sp, #8
10001b6e:	bd80      	pop	{r7, pc}

10001b70 <XMC_USIC_CH_TriggerServiceRequest>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TriggerServiceRequest(XMC_USIC_CH_t *const channel, const uint32_t service_request_line)
{
10001b70:	b580      	push	{r7, lr}
10001b72:	b082      	sub	sp, #8
10001b74:	af00      	add	r7, sp, #0
10001b76:	6078      	str	r0, [r7, #4]
10001b78:	6039      	str	r1, [r7, #0]
  channel->FMR = (uint32_t)(USIC_CH_FMR_SIO0_Msk << service_request_line);
10001b7a:	683b      	ldr	r3, [r7, #0]
10001b7c:	2280      	movs	r2, #128	; 0x80
10001b7e:	0252      	lsls	r2, r2, #9
10001b80:	409a      	lsls	r2, r3
10001b82:	687b      	ldr	r3, [r7, #4]
10001b84:	669a      	str	r2, [r3, #104]	; 0x68
}
10001b86:	46bd      	mov	sp, r7
10001b88:	b002      	add	sp, #8
10001b8a:	bd80      	pop	{r7, pc}

10001b8c <XMC_USIC_CH_TXFIFO_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001b8c:	b580      	push	{r7, lr}
10001b8e:	b082      	sub	sp, #8
10001b90:	af00      	add	r7, sp, #0
10001b92:	6078      	str	r0, [r7, #4]
10001b94:	6039      	str	r1, [r7, #0]
  channel->TBCTR |= event;
10001b96:	687a      	ldr	r2, [r7, #4]
10001b98:	2384      	movs	r3, #132	; 0x84
10001b9a:	005b      	lsls	r3, r3, #1
10001b9c:	58d2      	ldr	r2, [r2, r3]
10001b9e:	683b      	ldr	r3, [r7, #0]
10001ba0:	431a      	orrs	r2, r3
10001ba2:	1c11      	adds	r1, r2, #0
10001ba4:	687a      	ldr	r2, [r7, #4]
10001ba6:	2384      	movs	r3, #132	; 0x84
10001ba8:	005b      	lsls	r3, r3, #1
10001baa:	50d1      	str	r1, [r2, r3]
}
10001bac:	46bd      	mov	sp, r7
10001bae:	b002      	add	sp, #8
10001bb0:	bd80      	pop	{r7, pc}
10001bb2:	46c0      	nop			; (mov r8, r8)

10001bb4 <XMC_USIC_CH_TXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001bb4:	b580      	push	{r7, lr}
10001bb6:	b082      	sub	sp, #8
10001bb8:	af00      	add	r7, sp, #0
10001bba:	6078      	str	r0, [r7, #4]
10001bbc:	6039      	str	r1, [r7, #0]
  channel->TBCTR &= (uint32_t)~event;
10001bbe:	687a      	ldr	r2, [r7, #4]
10001bc0:	2384      	movs	r3, #132	; 0x84
10001bc2:	005b      	lsls	r3, r3, #1
10001bc4:	58d3      	ldr	r3, [r2, r3]
10001bc6:	683a      	ldr	r2, [r7, #0]
10001bc8:	43d2      	mvns	r2, r2
10001bca:	401a      	ands	r2, r3
10001bcc:	1c11      	adds	r1, r2, #0
10001bce:	687a      	ldr	r2, [r7, #4]
10001bd0:	2384      	movs	r3, #132	; 0x84
10001bd2:	005b      	lsls	r3, r3, #1
10001bd4:	50d1      	str	r1, [r2, r3]
}
10001bd6:	46bd      	mov	sp, r7
10001bd8:	b002      	add	sp, #8
10001bda:	bd80      	pop	{r7, pc}

10001bdc <XMC_USIC_CH_TXFIFO_Flush>:
 * 
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
10001bdc:	b580      	push	{r7, lr}
10001bde:	b082      	sub	sp, #8
10001be0:	af00      	add	r7, sp, #0
10001be2:	6078      	str	r0, [r7, #4]
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHTB_Msk;
10001be4:	687a      	ldr	r2, [r7, #4]
10001be6:	238c      	movs	r3, #140	; 0x8c
10001be8:	005b      	lsls	r3, r3, #1
10001bea:	2180      	movs	r1, #128	; 0x80
10001bec:	0209      	lsls	r1, r1, #8
10001bee:	50d1      	str	r1, [r2, r3]
}
10001bf0:	46bd      	mov	sp, r7
10001bf2:	b002      	add	sp, #8
10001bf4:	bd80      	pop	{r7, pc}
10001bf6:	46c0      	nop			; (mov r8, r8)

10001bf8 <XMC_USIC_CH_TXFIFO_IsFull>:
 * 
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
10001bf8:	b580      	push	{r7, lr}
10001bfa:	b082      	sub	sp, #8
10001bfc:	af00      	add	r7, sp, #0
10001bfe:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
10001c00:	687a      	ldr	r2, [r7, #4]
10001c02:	238a      	movs	r3, #138	; 0x8a
10001c04:	005b      	lsls	r3, r3, #1
10001c06:	58d2      	ldr	r2, [r2, r3]
10001c08:	2380      	movs	r3, #128	; 0x80
10001c0a:	015b      	lsls	r3, r3, #5
10001c0c:	4013      	ands	r3, r2
10001c0e:	1e5a      	subs	r2, r3, #1
10001c10:	4193      	sbcs	r3, r2
10001c12:	b2db      	uxtb	r3, r3
}
10001c14:	1c18      	adds	r0, r3, #0
10001c16:	46bd      	mov	sp, r7
10001c18:	b002      	add	sp, #8
10001c1a:	bd80      	pop	{r7, pc}

10001c1c <XMC_USIC_CH_TXFIFO_IsEmpty>:
 * 
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
10001c1c:	b580      	push	{r7, lr}
10001c1e:	b082      	sub	sp, #8
10001c20:	af00      	add	r7, sp, #0
10001c22:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TEMPTY_Msk);
10001c24:	687a      	ldr	r2, [r7, #4]
10001c26:	238a      	movs	r3, #138	; 0x8a
10001c28:	005b      	lsls	r3, r3, #1
10001c2a:	58d2      	ldr	r2, [r2, r3]
10001c2c:	2380      	movs	r3, #128	; 0x80
10001c2e:	011b      	lsls	r3, r3, #4
10001c30:	4013      	ands	r3, r2
10001c32:	1e5a      	subs	r2, r3, #1
10001c34:	4193      	sbcs	r3, r2
10001c36:	b2db      	uxtb	r3, r3
}
10001c38:	1c18      	adds	r0, r3, #0
10001c3a:	46bd      	mov	sp, r7
10001c3c:	b002      	add	sp, #8
10001c3e:	bd80      	pop	{r7, pc}

10001c40 <XMC_USIC_CH_RXFIFO_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001c40:	b580      	push	{r7, lr}
10001c42:	b082      	sub	sp, #8
10001c44:	af00      	add	r7, sp, #0
10001c46:	6078      	str	r0, [r7, #4]
10001c48:	6039      	str	r1, [r7, #0]
  channel->RBCTR |= event;
10001c4a:	687a      	ldr	r2, [r7, #4]
10001c4c:	2386      	movs	r3, #134	; 0x86
10001c4e:	005b      	lsls	r3, r3, #1
10001c50:	58d2      	ldr	r2, [r2, r3]
10001c52:	683b      	ldr	r3, [r7, #0]
10001c54:	431a      	orrs	r2, r3
10001c56:	1c11      	adds	r1, r2, #0
10001c58:	687a      	ldr	r2, [r7, #4]
10001c5a:	2386      	movs	r3, #134	; 0x86
10001c5c:	005b      	lsls	r3, r3, #1
10001c5e:	50d1      	str	r1, [r2, r3]
}
10001c60:	46bd      	mov	sp, r7
10001c62:	b002      	add	sp, #8
10001c64:	bd80      	pop	{r7, pc}
10001c66:	46c0      	nop			; (mov r8, r8)

10001c68 <XMC_USIC_CH_RXFIFO_DisableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetEvent(), XMC_USIC_CH_RXFIFO_EnableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
10001c68:	b580      	push	{r7, lr}
10001c6a:	b082      	sub	sp, #8
10001c6c:	af00      	add	r7, sp, #0
10001c6e:	6078      	str	r0, [r7, #4]
10001c70:	6039      	str	r1, [r7, #0]
  channel->RBCTR &= (uint32_t)~event;
10001c72:	687a      	ldr	r2, [r7, #4]
10001c74:	2386      	movs	r3, #134	; 0x86
10001c76:	005b      	lsls	r3, r3, #1
10001c78:	58d3      	ldr	r3, [r2, r3]
10001c7a:	683a      	ldr	r2, [r7, #0]
10001c7c:	43d2      	mvns	r2, r2
10001c7e:	401a      	ands	r2, r3
10001c80:	1c11      	adds	r1, r2, #0
10001c82:	687a      	ldr	r2, [r7, #4]
10001c84:	2386      	movs	r3, #134	; 0x86
10001c86:	005b      	lsls	r3, r3, #1
10001c88:	50d1      	str	r1, [r2, r3]
}
10001c8a:	46bd      	mov	sp, r7
10001c8c:	b002      	add	sp, #8
10001c8e:	bd80      	pop	{r7, pc}

10001c90 <XMC_USIC_CH_RXFIFO_Flush>:
 * 
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_GetLevel() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_RXFIFO_Flush(XMC_USIC_CH_t *const channel)
{
10001c90:	b580      	push	{r7, lr}
10001c92:	b082      	sub	sp, #8
10001c94:	af00      	add	r7, sp, #0
10001c96:	6078      	str	r0, [r7, #4]
  channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHRB_Msk;
10001c98:	687a      	ldr	r2, [r7, #4]
10001c9a:	238c      	movs	r3, #140	; 0x8c
10001c9c:	005b      	lsls	r3, r3, #1
10001c9e:	2180      	movs	r1, #128	; 0x80
10001ca0:	01c9      	lsls	r1, r1, #7
10001ca2:	50d1      	str	r1, [r2, r3]
}
10001ca4:	46bd      	mov	sp, r7
10001ca6:	b002      	add	sp, #8
10001ca8:	bd80      	pop	{r7, pc}
10001caa:	46c0      	nop			; (mov r8, r8)

10001cac <XMC_USIC_CH_RXFIFO_IsEmpty>:
 * 
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
10001cac:	b580      	push	{r7, lr}
10001cae:	b082      	sub	sp, #8
10001cb0:	af00      	add	r7, sp, #0
10001cb2:	6078      	str	r0, [r7, #4]
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
10001cb4:	687a      	ldr	r2, [r7, #4]
10001cb6:	238a      	movs	r3, #138	; 0x8a
10001cb8:	005b      	lsls	r3, r3, #1
10001cba:	58d3      	ldr	r3, [r2, r3]
10001cbc:	2208      	movs	r2, #8
10001cbe:	4013      	ands	r3, r2
10001cc0:	1e5a      	subs	r2, r3, #1
10001cc2:	4193      	sbcs	r3, r2
10001cc4:	b2db      	uxtb	r3, r3
}
10001cc6:	1c18      	adds	r0, r3, #0
10001cc8:	46bd      	mov	sp, r7
10001cca:	b002      	add	sp, #8
10001ccc:	bd80      	pop	{r7, pc}
10001cce:	46c0      	nop			; (mov r8, r8)

10001cd0 <UART_Init>:
 *          UART_SUCCESS: for successful UART initialization.<BR>
 *          UART_STATUS_FAILURE  : If UART initialization fails.<BR>
 *
 */
UART_STATUS_t UART_Init(const UART_t *const handle)
{
10001cd0:	b590      	push	{r4, r7, lr}
10001cd2:	b085      	sub	sp, #20
10001cd4:	af00      	add	r7, sp, #0
10001cd6:	6078      	str	r0, [r7, #4]
  UART_STATUS_t status = UART_STATUS_SUCCESS;
10001cd8:	230f      	movs	r3, #15
10001cda:	18fb      	adds	r3, r7, r3
10001cdc:	2200      	movs	r2, #0
10001cde:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("UART_Init : UART APP handle invalid", (((handle != NULL)&&
      (handle->config != NULL)) &&((handle->config->fptr_uart_config != NULL)&&
      (handle->runtime != NULL))))

  /*Initialize the multiplexers required for UART configuration*/
  status = handle->config->fptr_uart_config();
10001ce0:	687b      	ldr	r3, [r7, #4]
10001ce2:	685b      	ldr	r3, [r3, #4]
10001ce4:	685b      	ldr	r3, [r3, #4]
10001ce6:	220f      	movs	r2, #15
10001ce8:	18bc      	adds	r4, r7, r2
10001cea:	4798      	blx	r3
10001cec:	1c03      	adds	r3, r0, #0
10001cee:	7023      	strb	r3, [r4, #0]

  return status;
10001cf0:	230f      	movs	r3, #15
10001cf2:	18fb      	adds	r3, r7, r3
10001cf4:	781b      	ldrb	r3, [r3, #0]
}
10001cf6:	1c18      	adds	r0, r3, #0
10001cf8:	46bd      	mov	sp, r7
10001cfa:	b005      	add	sp, #20
10001cfc:	bd90      	pop	{r4, r7, pc}
10001cfe:	46c0      	nop			; (mov r8, r8)

10001d00 <UART_Transmit>:
 *          UART_STATUS_BUFFER_INVALID: Either if buffer is NULL or count is 0.<BR>
 *          UART_STATUS_MODE_MISMATCH: If the configured mode is invalid.<BR>
 *
 */
UART_STATUS_t UART_Transmit(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10001d00:	b590      	push	{r4, r7, lr}
10001d02:	b087      	sub	sp, #28
10001d04:	af00      	add	r7, sp, #0
10001d06:	60f8      	str	r0, [r7, #12]
10001d08:	60b9      	str	r1, [r7, #8]
10001d0a:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
10001d0c:	2317      	movs	r3, #23
10001d0e:	18fb      	adds	r3, r7, r3
10001d10:	2204      	movs	r2, #4
10001d12:	701a      	strb	r2, [r3, #0]

  switch(handle->config->transmit_mode)
10001d14:	68fb      	ldr	r3, [r7, #12]
10001d16:	685b      	ldr	r3, [r3, #4]
10001d18:	2229      	movs	r2, #41	; 0x29
10001d1a:	5c9b      	ldrb	r3, [r3, r2]
10001d1c:	2b00      	cmp	r3, #0
10001d1e:	d000      	beq.n	10001d22 <UART_Transmit+0x22>
  case UART_TRANSFER_MODE_DIRECT:
    ret_stat = UART_lStartTransmitPolling(handle, data_ptr, count);
    break;
#endif
  default:
    break;
10001d20:	e00c      	b.n	10001d3c <UART_Transmit+0x3c>

  switch(handle->config->transmit_mode)
  {
#ifdef UART_TX_INTERRUPT_USED
  case UART_TRANSFER_MODE_INTERRUPT:
    ret_stat = UART_StartTransmitIRQ(handle, data_ptr, count);
10001d22:	2317      	movs	r3, #23
10001d24:	18fc      	adds	r4, r7, r3
10001d26:	68f9      	ldr	r1, [r7, #12]
10001d28:	68ba      	ldr	r2, [r7, #8]
10001d2a:	687b      	ldr	r3, [r7, #4]
10001d2c:	1c08      	adds	r0, r1, #0
10001d2e:	1c11      	adds	r1, r2, #0
10001d30:	1c1a      	adds	r2, r3, #0
10001d32:	f000 f831 	bl	10001d98 <UART_StartTransmitIRQ>
10001d36:	1c03      	adds	r3, r0, #0
10001d38:	7023      	strb	r3, [r4, #0]
    break;
10001d3a:	46c0      	nop			; (mov r8, r8)
    break;
#endif
  default:
    break;
  }
  return ret_stat;
10001d3c:	2317      	movs	r3, #23
10001d3e:	18fb      	adds	r3, r7, r3
10001d40:	781b      	ldrb	r3, [r3, #0]
}
10001d42:	1c18      	adds	r0, r3, #0
10001d44:	46bd      	mov	sp, r7
10001d46:	b007      	add	sp, #28
10001d48:	bd90      	pop	{r4, r7, pc}
10001d4a:	46c0      	nop			; (mov r8, r8)

10001d4c <UART_Receive>:
 *          UART_STATUS_BUFFER_INVALID: Either if buffer is NULL or count is 0.<BR>
 *          UART_STATUS_MODE_MISMATCH: If the configured mode is invalid.<BR>
 *
 */
UART_STATUS_t UART_Receive(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10001d4c:	b590      	push	{r4, r7, lr}
10001d4e:	b087      	sub	sp, #28
10001d50:	af00      	add	r7, sp, #0
10001d52:	60f8      	str	r0, [r7, #12]
10001d54:	60b9      	str	r1, [r7, #8]
10001d56:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
10001d58:	2317      	movs	r3, #23
10001d5a:	18fb      	adds	r3, r7, r3
10001d5c:	2204      	movs	r2, #4
10001d5e:	701a      	strb	r2, [r3, #0]

  switch(handle->config->receive_mode)
10001d60:	68fb      	ldr	r3, [r7, #12]
10001d62:	685b      	ldr	r3, [r3, #4]
10001d64:	222a      	movs	r2, #42	; 0x2a
10001d66:	5c9b      	ldrb	r3, [r3, r2]
10001d68:	2b00      	cmp	r3, #0
10001d6a:	d000      	beq.n	10001d6e <UART_Receive+0x22>
  case UART_TRANSFER_MODE_DIRECT:
    ret_stat = UART_lStartReceivePolling(handle, data_ptr, count);
    break;
#endif
  default:
    break;
10001d6c:	e00c      	b.n	10001d88 <UART_Receive+0x3c>

  switch(handle->config->receive_mode)
  {
#ifdef UART_RX_INTERRUPT_USED
  case UART_TRANSFER_MODE_INTERRUPT:
    ret_stat = UART_StartReceiveIRQ(handle, data_ptr, count);
10001d6e:	2317      	movs	r3, #23
10001d70:	18fc      	adds	r4, r7, r3
10001d72:	68f9      	ldr	r1, [r7, #12]
10001d74:	68ba      	ldr	r2, [r7, #8]
10001d76:	687b      	ldr	r3, [r7, #4]
10001d78:	1c08      	adds	r0, r1, #0
10001d7a:	1c11      	adds	r1, r2, #0
10001d7c:	1c1a      	adds	r2, r3, #0
10001d7e:	f000 f873 	bl	10001e68 <UART_StartReceiveIRQ>
10001d82:	1c03      	adds	r3, r0, #0
10001d84:	7023      	strb	r3, [r4, #0]
    break;
10001d86:	46c0      	nop			; (mov r8, r8)
    break;
#endif
  default:
    break;
  }
  return ret_stat;
10001d88:	2317      	movs	r3, #23
10001d8a:	18fb      	adds	r3, r7, r3
10001d8c:	781b      	ldrb	r3, [r3, #0]
}
10001d8e:	1c18      	adds	r0, r3, #0
10001d90:	46bd      	mov	sp, r7
10001d92:	b007      	add	sp, #28
10001d94:	bd90      	pop	{r4, r7, pc}
10001d96:	46c0      	nop			; (mov r8, r8)

10001d98 <UART_StartTransmitIRQ>:
 * request is registered.
 *
 *
 */
UART_STATUS_t UART_StartTransmitIRQ(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10001d98:	b580      	push	{r7, lr}
10001d9a:	b086      	sub	sp, #24
10001d9c:	af00      	add	r7, sp, #0
10001d9e:	60f8      	str	r0, [r7, #12]
10001da0:	60b9      	str	r1, [r7, #8]
10001da2:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
10001da4:	2317      	movs	r3, #23
10001da6:	18fb      	adds	r3, r7, r3
10001da8:	2204      	movs	r2, #4
10001daa:	701a      	strb	r2, [r3, #0]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10001dac:	68fb      	ldr	r3, [r7, #12]
10001dae:	689b      	ldr	r3, [r3, #8]
10001db0:	613b      	str	r3, [r7, #16]

  XMC_ASSERT("UART_StartTransmitIRQ: UART APP handle invalid", ((handle != NULL)&&
            (handle->runtime != NULL)))

  if (handle->config->transmit_mode == UART_TRANSFER_MODE_INTERRUPT)
10001db2:	68fb      	ldr	r3, [r7, #12]
10001db4:	685b      	ldr	r3, [r3, #4]
10001db6:	2229      	movs	r2, #41	; 0x29
10001db8:	5c9b      	ldrb	r3, [r3, r2]
10001dba:	2b00      	cmp	r3, #0
10001dbc:	d14c      	bne.n	10001e58 <UART_StartTransmitIRQ+0xc0>
  {
    ret_stat = UART_STATUS_BUSY;
10001dbe:	2317      	movs	r3, #23
10001dc0:	18fb      	adds	r3, r7, r3
10001dc2:	2202      	movs	r2, #2
10001dc4:	701a      	strb	r2, [r3, #0]
    if (ptr_runtime->tx_busy == false)
10001dc6:	693b      	ldr	r3, [r7, #16]
10001dc8:	7e1b      	ldrb	r3, [r3, #24]
10001dca:	b2db      	uxtb	r3, r3
10001dcc:	2201      	movs	r2, #1
10001dce:	4053      	eors	r3, r2
10001dd0:	b2db      	uxtb	r3, r3
10001dd2:	2b00      	cmp	r3, #0
10001dd4:	d040      	beq.n	10001e58 <UART_StartTransmitIRQ+0xc0>
    {
      /*If there is no transmission in progress*/
      if ((data_ptr != NULL) && (count > 0U))
10001dd6:	68bb      	ldr	r3, [r7, #8]
10001dd8:	2b00      	cmp	r3, #0
10001dda:	d039      	beq.n	10001e50 <UART_StartTransmitIRQ+0xb8>
10001ddc:	687b      	ldr	r3, [r7, #4]
10001dde:	2b00      	cmp	r3, #0
10001de0:	d036      	beq.n	10001e50 <UART_StartTransmitIRQ+0xb8>
      {
        /*Obtain the address of data, size of data*/
        ptr_runtime->tx_data = data_ptr;
10001de2:	693b      	ldr	r3, [r7, #16]
10001de4:	68ba      	ldr	r2, [r7, #8]
10001de6:	601a      	str	r2, [r3, #0]
        ptr_runtime->tx_data_count = count;
10001de8:	693b      	ldr	r3, [r7, #16]
10001dea:	687a      	ldr	r2, [r7, #4]
10001dec:	609a      	str	r2, [r3, #8]
        /*Initialize to first index and set the busy flag*/
        ptr_runtime->tx_data_index = 0U;
10001dee:	693b      	ldr	r3, [r7, #16]
10001df0:	2200      	movs	r2, #0
10001df2:	60da      	str	r2, [r3, #12]
        ptr_runtime->tx_busy = true;
10001df4:	693b      	ldr	r3, [r7, #16]
10001df6:	2201      	movs	r2, #1
10001df8:	761a      	strb	r2, [r3, #24]

        /*Enable the transmit buffer event*/
        if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10001dfa:	68fb      	ldr	r3, [r7, #12]
10001dfc:	685b      	ldr	r3, [r3, #4]
10001dfe:	222b      	movs	r2, #43	; 0x2b
10001e00:	5c9b      	ldrb	r3, [r3, r2]
10001e02:	2b00      	cmp	r3, #0
10001e04:	d00d      	beq.n	10001e22 <UART_StartTransmitIRQ+0x8a>
        {
          /*Clear the transmit FIFO*/
          XMC_USIC_CH_TXFIFO_Flush(handle->channel);
10001e06:	68fb      	ldr	r3, [r7, #12]
10001e08:	681b      	ldr	r3, [r3, #0]
10001e0a:	1c18      	adds	r0, r3, #0
10001e0c:	f7ff fee6 	bl	10001bdc <XMC_USIC_CH_TXFIFO_Flush>
          /*Enable transmit buffer interrupt*/
          XMC_USIC_CH_TXFIFO_EnableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
10001e10:	68fb      	ldr	r3, [r7, #12]
10001e12:	681a      	ldr	r2, [r3, #0]
10001e14:	2380      	movs	r3, #128	; 0x80
10001e16:	05db      	lsls	r3, r3, #23
10001e18:	1c10      	adds	r0, r2, #0
10001e1a:	1c19      	adds	r1, r3, #0
10001e1c:	f7ff feb6 	bl	10001b8c <XMC_USIC_CH_TXFIFO_EnableEvent>
10001e20:	e007      	b.n	10001e32 <UART_StartTransmitIRQ+0x9a>
        }
        else
        {
          XMC_USIC_CH_EnableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
10001e22:	68fb      	ldr	r3, [r7, #12]
10001e24:	681a      	ldr	r2, [r3, #0]
10001e26:	2380      	movs	r3, #128	; 0x80
10001e28:	019b      	lsls	r3, r3, #6
10001e2a:	1c10      	adds	r0, r2, #0
10001e2c:	1c19      	adds	r1, r3, #0
10001e2e:	f7ff fe73 	bl	10001b18 <XMC_USIC_CH_EnableEvent>
        }
        ret_stat = UART_STATUS_SUCCESS;
10001e32:	2317      	movs	r3, #23
10001e34:	18fb      	adds	r3, r7, r3
10001e36:	2200      	movs	r2, #0
10001e38:	701a      	strb	r2, [r3, #0]
        /*Trigger the transmit buffer interrupt*/
        XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)handle->config->tx_sr);
10001e3a:	68fb      	ldr	r3, [r7, #12]
10001e3c:	6819      	ldr	r1, [r3, #0]
10001e3e:	68fb      	ldr	r3, [r7, #12]
10001e40:	685b      	ldr	r3, [r3, #4]
10001e42:	222d      	movs	r2, #45	; 0x2d
10001e44:	5c9b      	ldrb	r3, [r3, r2]
10001e46:	1c08      	adds	r0, r1, #0
10001e48:	1c19      	adds	r1, r3, #0
10001e4a:	f7ff fe91 	bl	10001b70 <XMC_USIC_CH_TriggerServiceRequest>
10001e4e:	e003      	b.n	10001e58 <UART_StartTransmitIRQ+0xc0>
      }
      else
      {
        ret_stat = UART_STATUS_BUFFER_INVALID;
10001e50:	2317      	movs	r3, #23
10001e52:	18fb      	adds	r3, r7, r3
10001e54:	2203      	movs	r2, #3
10001e56:	701a      	strb	r2, [r3, #0]
      }
    }
  }
  return ret_stat;
10001e58:	2317      	movs	r3, #23
10001e5a:	18fb      	adds	r3, r7, r3
10001e5c:	781b      	ldrb	r3, [r3, #0]
}
10001e5e:	1c18      	adds	r0, r3, #0
10001e60:	46bd      	mov	sp, r7
10001e62:	b006      	add	sp, #24
10001e64:	bd80      	pop	{r7, pc}
10001e66:	46c0      	nop			; (mov r8, r8)

10001e68 <UART_StartReceiveIRQ>:
 * request is registered.
 *
 *
 */
UART_STATUS_t UART_StartReceiveIRQ(const UART_t *const handle, uint8_t* data_ptr, uint32_t count)
{
10001e68:	b580      	push	{r7, lr}
10001e6a:	b086      	sub	sp, #24
10001e6c:	af00      	add	r7, sp, #0
10001e6e:	60f8      	str	r0, [r7, #12]
10001e70:	60b9      	str	r1, [r7, #8]
10001e72:	607a      	str	r2, [r7, #4]
  UART_STATUS_t ret_stat = UART_STATUS_MODE_MISMATCH;
10001e74:	2317      	movs	r3, #23
10001e76:	18fb      	adds	r3, r7, r3
10001e78:	2204      	movs	r2, #4
10001e7a:	701a      	strb	r2, [r3, #0]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10001e7c:	68fb      	ldr	r3, [r7, #12]
10001e7e:	689b      	ldr	r3, [r3, #8]
10001e80:	613b      	str	r3, [r7, #16]

  XMC_ASSERT("UART_StartReceiveIRQ: UART APP handle invalid", ((handle != NULL)&&
            (handle->runtime != NULL)))

  if (handle->config->receive_mode == UART_TRANSFER_MODE_INTERRUPT)
10001e82:	68fb      	ldr	r3, [r7, #12]
10001e84:	685b      	ldr	r3, [r3, #4]
10001e86:	222a      	movs	r2, #42	; 0x2a
10001e88:	5c9b      	ldrb	r3, [r3, r2]
10001e8a:	2b00      	cmp	r3, #0
10001e8c:	d148      	bne.n	10001f20 <UART_StartReceiveIRQ+0xb8>
  {
    ret_stat = UART_STATUS_BUSY;
10001e8e:	2317      	movs	r3, #23
10001e90:	18fb      	adds	r3, r7, r3
10001e92:	2202      	movs	r2, #2
10001e94:	701a      	strb	r2, [r3, #0]
    if (ptr_runtime->rx_busy == false)
10001e96:	693b      	ldr	r3, [r7, #16]
10001e98:	7e5b      	ldrb	r3, [r3, #25]
10001e9a:	b2db      	uxtb	r3, r3
10001e9c:	2201      	movs	r2, #1
10001e9e:	4053      	eors	r3, r2
10001ea0:	b2db      	uxtb	r3, r3
10001ea2:	2b00      	cmp	r3, #0
10001ea4:	d03c      	beq.n	10001f20 <UART_StartReceiveIRQ+0xb8>
    {
      /*If no active reception in progress*/
      if ((data_ptr != NULL) && (count > 0U))
10001ea6:	68bb      	ldr	r3, [r7, #8]
10001ea8:	2b00      	cmp	r3, #0
10001eaa:	d035      	beq.n	10001f18 <UART_StartReceiveIRQ+0xb0>
10001eac:	687b      	ldr	r3, [r7, #4]
10001eae:	2b00      	cmp	r3, #0
10001eb0:	d032      	beq.n	10001f18 <UART_StartReceiveIRQ+0xb0>
      {
        /*Obtain the address of data buffer and
         * number of data bytes to be received*/
        ptr_runtime->rx_data = data_ptr;
10001eb2:	693b      	ldr	r3, [r7, #16]
10001eb4:	68ba      	ldr	r2, [r7, #8]
10001eb6:	605a      	str	r2, [r3, #4]
        ptr_runtime->rx_data_count = count;
10001eb8:	693b      	ldr	r3, [r7, #16]
10001eba:	687a      	ldr	r2, [r7, #4]
10001ebc:	611a      	str	r2, [r3, #16]
        ptr_runtime->rx_busy = true;
10001ebe:	693b      	ldr	r3, [r7, #16]
10001ec0:	2201      	movs	r2, #1
10001ec2:	765a      	strb	r2, [r3, #25]
        ptr_runtime->rx_data_index = 0U;
10001ec4:	693b      	ldr	r3, [r7, #16]
10001ec6:	2200      	movs	r2, #0
10001ec8:	615a      	str	r2, [r3, #20]

        if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10001eca:	68fb      	ldr	r3, [r7, #12]
10001ecc:	685b      	ldr	r3, [r3, #4]
10001ece:	222c      	movs	r2, #44	; 0x2c
10001ed0:	5c9b      	ldrb	r3, [r3, r2]
10001ed2:	2b00      	cmp	r3, #0
10001ed4:	d013      	beq.n	10001efe <UART_StartReceiveIRQ+0x96>
        {
          /*Clear the receive FIFO, configure the trigger lime
           * and enable the receive events*/
          XMC_USIC_CH_RXFIFO_Flush(handle->channel);
10001ed6:	68fb      	ldr	r3, [r7, #12]
10001ed8:	681b      	ldr	r3, [r3, #0]
10001eda:	1c18      	adds	r0, r3, #0
10001edc:	f7ff fed8 	bl	10001c90 <XMC_USIC_CH_RXFIFO_Flush>

          /*Configure the FIFO trigger limit based on the required data size*/
          UART_lReconfigureRxFIFO(handle, count);
10001ee0:	68fa      	ldr	r2, [r7, #12]
10001ee2:	687b      	ldr	r3, [r7, #4]
10001ee4:	1c10      	adds	r0, r2, #0
10001ee6:	1c19      	adds	r1, r3, #0
10001ee8:	f000 f93e 	bl	10002168 <UART_lReconfigureRxFIFO>

          XMC_USIC_CH_RXFIFO_EnableEvent(handle->channel,
10001eec:	68fb      	ldr	r3, [r7, #12]
10001eee:	681a      	ldr	r2, [r3, #0]
10001ef0:	23c0      	movs	r3, #192	; 0xc0
10001ef2:	05db      	lsls	r3, r3, #23
10001ef4:	1c10      	adds	r0, r2, #0
10001ef6:	1c19      	adds	r1, r3, #0
10001ef8:	f7ff fea2 	bl	10001c40 <XMC_USIC_CH_RXFIFO_EnableEvent>
10001efc:	e007      	b.n	10001f0e <UART_StartReceiveIRQ+0xa6>
            (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
        }
        else
        {
          XMC_USIC_CH_EnableEvent(handle->channel,
10001efe:	68fb      	ldr	r3, [r7, #12]
10001f00:	681a      	ldr	r2, [r3, #0]
10001f02:	23c0      	movs	r3, #192	; 0xc0
10001f04:	021b      	lsls	r3, r3, #8
10001f06:	1c10      	adds	r0, r2, #0
10001f08:	1c19      	adds	r1, r3, #0
10001f0a:	f7ff fe05 	bl	10001b18 <XMC_USIC_CH_EnableEvent>
          (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
        }
        ret_stat = UART_STATUS_SUCCESS;
10001f0e:	2317      	movs	r3, #23
10001f10:	18fb      	adds	r3, r7, r3
10001f12:	2200      	movs	r2, #0
10001f14:	701a      	strb	r2, [r3, #0]
10001f16:	e003      	b.n	10001f20 <UART_StartReceiveIRQ+0xb8>
      }
      else
      {
        ret_stat = UART_STATUS_BUFFER_INVALID;
10001f18:	2317      	movs	r3, #23
10001f1a:	18fb      	adds	r3, r7, r3
10001f1c:	2203      	movs	r2, #3
10001f1e:	701a      	strb	r2, [r3, #0]
      }
    }
  }
  return ret_stat;
10001f20:	2317      	movs	r3, #23
10001f22:	18fb      	adds	r3, r7, r3
10001f24:	781b      	ldrb	r3, [r3, #0]
}
10001f26:	1c18      	adds	r0, r3, #0
10001f28:	46bd      	mov	sp, r7
10001f2a:	b006      	add	sp, #24
10001f2c:	bd80      	pop	{r7, pc}
10001f2e:	46c0      	nop			; (mov r8, r8)

10001f30 <UART_lTransmitHandler>:
 *  * param[in]  handle UART APP handle pointer of type UART_t*
 *
 *  * return void
 */
void UART_lTransmitHandler(const UART_t * const handle)
{
10001f30:	b580      	push	{r7, lr}
10001f32:	b084      	sub	sp, #16
10001f34:	af00      	add	r7, sp, #0
10001f36:	6078      	str	r0, [r7, #4]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10001f38:	687b      	ldr	r3, [r7, #4]
10001f3a:	689b      	ldr	r3, [r3, #8]
10001f3c:	60fb      	str	r3, [r7, #12]

  if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
10001f3e:	68fb      	ldr	r3, [r7, #12]
10001f40:	68da      	ldr	r2, [r3, #12]
10001f42:	68fb      	ldr	r3, [r7, #12]
10001f44:	689b      	ldr	r3, [r3, #8]
10001f46:	429a      	cmp	r2, r3
10001f48:	d241      	bcs.n	10001fce <UART_lTransmitHandler+0x9e>
  {
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10001f4a:	687b      	ldr	r3, [r7, #4]
10001f4c:	685b      	ldr	r3, [r3, #4]
10001f4e:	222b      	movs	r2, #43	; 0x2b
10001f50:	5c9b      	ldrb	r3, [r3, r2]
10001f52:	2b00      	cmp	r3, #0
10001f54:	d028      	beq.n	10001fa8 <UART_lTransmitHandler+0x78>
    {
      /*When Transmit FIFO is enabled*/
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
10001f56:	e01a      	b.n	10001f8e <UART_lTransmitHandler+0x5e>
      {
        if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
10001f58:	68fb      	ldr	r3, [r7, #12]
10001f5a:	68da      	ldr	r2, [r3, #12]
10001f5c:	68fb      	ldr	r3, [r7, #12]
10001f5e:	689b      	ldr	r3, [r3, #8]
10001f60:	429a      	cmp	r2, r3
10001f62:	d212      	bcs.n	10001f8a <UART_lTransmitHandler+0x5a>
        {
          /*Load the FIFO byte by byte till either FIFO is full or all data is loaded*/
          XMC_UART_CH_Transmit(handle->channel,(uint16_t)ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
10001f64:	687b      	ldr	r3, [r7, #4]
10001f66:	6819      	ldr	r1, [r3, #0]
10001f68:	68fb      	ldr	r3, [r7, #12]
10001f6a:	681a      	ldr	r2, [r3, #0]
10001f6c:	68fb      	ldr	r3, [r7, #12]
10001f6e:	68db      	ldr	r3, [r3, #12]
10001f70:	18d3      	adds	r3, r2, r3
10001f72:	781b      	ldrb	r3, [r3, #0]
10001f74:	b29b      	uxth	r3, r3
10001f76:	1c08      	adds	r0, r1, #0
10001f78:	1c19      	adds	r1, r3, #0
10001f7a:	f7ff fbd7 	bl	1000172c <XMC_UART_CH_Transmit>
          (ptr_runtime->tx_data_index)++;
10001f7e:	68fb      	ldr	r3, [r7, #12]
10001f80:	68db      	ldr	r3, [r3, #12]
10001f82:	1c5a      	adds	r2, r3, #1
10001f84:	68fb      	ldr	r3, [r7, #12]
10001f86:	60da      	str	r2, [r3, #12]
10001f88:	e001      	b.n	10001f8e <UART_lTransmitHandler+0x5e>
        }
        else
        {
          break;
10001f8a:	46c0      	nop			; (mov r8, r8)
10001f8c:	e055      	b.n	1000203a <UART_lTransmitHandler+0x10a>
  {
    if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
    {
      /*When Transmit FIFO is enabled*/
      /*Fill the transmit FIFO */
      while (XMC_USIC_CH_TXFIFO_IsFull(handle->channel) == false)
10001f8e:	687b      	ldr	r3, [r7, #4]
10001f90:	681b      	ldr	r3, [r3, #0]
10001f92:	1c18      	adds	r0, r3, #0
10001f94:	f7ff fe30 	bl	10001bf8 <XMC_USIC_CH_TXFIFO_IsFull>
10001f98:	1c03      	adds	r3, r0, #0
10001f9a:	1c1a      	adds	r2, r3, #0
10001f9c:	2301      	movs	r3, #1
10001f9e:	4053      	eors	r3, r2
10001fa0:	b2db      	uxtb	r3, r3
10001fa2:	2b00      	cmp	r3, #0
10001fa4:	d1d8      	bne.n	10001f58 <UART_lTransmitHandler+0x28>
10001fa6:	e048      	b.n	1000203a <UART_lTransmitHandler+0x10a>
      }
    }
    else
    {
      /*When Transmit FIFO is disabled*/
      XMC_UART_CH_Transmit(handle->channel,(uint16_t)ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
10001fa8:	687b      	ldr	r3, [r7, #4]
10001faa:	6819      	ldr	r1, [r3, #0]
10001fac:	68fb      	ldr	r3, [r7, #12]
10001fae:	681a      	ldr	r2, [r3, #0]
10001fb0:	68fb      	ldr	r3, [r7, #12]
10001fb2:	68db      	ldr	r3, [r3, #12]
10001fb4:	18d3      	adds	r3, r2, r3
10001fb6:	781b      	ldrb	r3, [r3, #0]
10001fb8:	b29b      	uxth	r3, r3
10001fba:	1c08      	adds	r0, r1, #0
10001fbc:	1c19      	adds	r1, r3, #0
10001fbe:	f7ff fbb5 	bl	1000172c <XMC_UART_CH_Transmit>
      (ptr_runtime->tx_data_index)++;
10001fc2:	68fb      	ldr	r3, [r7, #12]
10001fc4:	68db      	ldr	r3, [r3, #12]
10001fc6:	1c5a      	adds	r2, r3, #1
10001fc8:	68fb      	ldr	r3, [r7, #12]
10001fca:	60da      	str	r2, [r3, #12]
10001fcc:	e035      	b.n	1000203a <UART_lTransmitHandler+0x10a>
    }
  }
  else
  {
    if (XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel) == true)
10001fce:	687b      	ldr	r3, [r7, #4]
10001fd0:	681b      	ldr	r3, [r3, #0]
10001fd2:	1c18      	adds	r0, r3, #0
10001fd4:	f7ff fe22 	bl	10001c1c <XMC_USIC_CH_TXFIFO_IsEmpty>
10001fd8:	1e03      	subs	r3, r0, #0
10001fda:	d02e      	beq.n	1000203a <UART_lTransmitHandler+0x10a>
    {
      if (handle->config->tx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
10001fdc:	687b      	ldr	r3, [r7, #4]
10001fde:	685b      	ldr	r3, [r3, #4]
10001fe0:	222b      	movs	r2, #43	; 0x2b
10001fe2:	5c9b      	ldrb	r3, [r3, r2]
10001fe4:	2b00      	cmp	r3, #0
10001fe6:	d008      	beq.n	10001ffa <UART_lTransmitHandler+0xca>
      {
        /*Disable the transmit FIFO event*/
        XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
10001fe8:	687b      	ldr	r3, [r7, #4]
10001fea:	681a      	ldr	r2, [r3, #0]
10001fec:	2380      	movs	r3, #128	; 0x80
10001fee:	05db      	lsls	r3, r3, #23
10001ff0:	1c10      	adds	r0, r2, #0
10001ff2:	1c19      	adds	r1, r3, #0
10001ff4:	f7ff fdde 	bl	10001bb4 <XMC_USIC_CH_TXFIFO_DisableEvent>
10001ff8:	e007      	b.n	1000200a <UART_lTransmitHandler+0xda>
      }
      else
      {
        /*Disable the standard transmit event*/
        XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
10001ffa:	687b      	ldr	r3, [r7, #4]
10001ffc:	681a      	ldr	r2, [r3, #0]
10001ffe:	2380      	movs	r3, #128	; 0x80
10002000:	019b      	lsls	r3, r3, #6
10002002:	1c10      	adds	r0, r2, #0
10002004:	1c19      	adds	r1, r3, #0
10002006:	f7ff fd95 	bl	10001b34 <XMC_USIC_CH_DisableEvent>
      }

      /*Wait for the transmit buffer to be free to ensure that all data is transmitted*/
      while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
1000200a:	46c0      	nop			; (mov r8, r8)
1000200c:	687b      	ldr	r3, [r7, #4]
1000200e:	681b      	ldr	r3, [r3, #0]
10002010:	1c18      	adds	r0, r3, #0
10002012:	f7ff fd9f 	bl	10001b54 <XMC_USIC_CH_GetTransmitBufferStatus>
10002016:	1e03      	subs	r3, r0, #0
10002018:	2b80      	cmp	r3, #128	; 0x80
1000201a:	d0f7      	beq.n	1000200c <UART_lTransmitHandler+0xdc>
      {

      }
      /*All data is transmitted*/
      ptr_runtime->tx_busy = false;
1000201c:	68fb      	ldr	r3, [r7, #12]
1000201e:	2200      	movs	r2, #0
10002020:	761a      	strb	r2, [r3, #24]
      ptr_runtime->tx_data = NULL;
10002022:	68fb      	ldr	r3, [r7, #12]
10002024:	2200      	movs	r2, #0
10002026:	601a      	str	r2, [r3, #0]

      if (handle->config->tx_cbhandler != NULL)
10002028:	687b      	ldr	r3, [r7, #4]
1000202a:	685b      	ldr	r3, [r3, #4]
1000202c:	689b      	ldr	r3, [r3, #8]
1000202e:	2b00      	cmp	r3, #0
10002030:	d003      	beq.n	1000203a <UART_lTransmitHandler+0x10a>
      {
        /*Execute the callback function provided in the UART APP UI*/
        handle->config->tx_cbhandler();
10002032:	687b      	ldr	r3, [r7, #4]
10002034:	685b      	ldr	r3, [r3, #4]
10002036:	689b      	ldr	r3, [r3, #8]
10002038:	4798      	blx	r3
      }
    }
  }
}
1000203a:	46bd      	mov	sp, r7
1000203c:	b004      	add	sp, #16
1000203e:	bd80      	pop	{r7, pc}

10002040 <UART_lReceiveHandler>:
 * param[in]  handle UART APP handle pointer of type UART_t*
 *
 * return void
 */
void UART_lReceiveHandler(const UART_t * const handle)
{
10002040:	b590      	push	{r4, r7, lr}
10002042:	b085      	sub	sp, #20
10002044:	af00      	add	r7, sp, #0
10002046:	6078      	str	r0, [r7, #4]
  UART_RUNTIME_t * ptr_runtime = handle->runtime;
10002048:	687b      	ldr	r3, [r7, #4]
1000204a:	689b      	ldr	r3, [r3, #8]
1000204c:	60fb      	str	r3, [r7, #12]

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
1000204e:	687b      	ldr	r3, [r7, #4]
10002050:	685b      	ldr	r3, [r3, #4]
10002052:	222c      	movs	r2, #44	; 0x2c
10002054:	5c9b      	ldrb	r3, [r3, r2]
10002056:	2b00      	cmp	r3, #0
10002058:	d051      	beq.n	100020fe <UART_lReceiveHandler+0xbe>
  {
    /*When Receive FIFO is enabled*/
    while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
1000205a:	e033      	b.n	100020c4 <UART_lReceiveHandler+0x84>
    {
      if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
1000205c:	68fb      	ldr	r3, [r7, #12]
1000205e:	695a      	ldr	r2, [r3, #20]
10002060:	68fb      	ldr	r3, [r7, #12]
10002062:	691b      	ldr	r3, [r3, #16]
10002064:	429a      	cmp	r2, r3
10002066:	d211      	bcs.n	1000208c <UART_lReceiveHandler+0x4c>
      {
        /*Read all the content of Receive FIFO */
        ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_UART_CH_GetReceivedData(handle->channel);
10002068:	68fb      	ldr	r3, [r7, #12]
1000206a:	685a      	ldr	r2, [r3, #4]
1000206c:	68fb      	ldr	r3, [r7, #12]
1000206e:	695b      	ldr	r3, [r3, #20]
10002070:	18d4      	adds	r4, r2, r3
10002072:	687b      	ldr	r3, [r7, #4]
10002074:	681b      	ldr	r3, [r3, #0]
10002076:	1c18      	adds	r0, r3, #0
10002078:	f7ff fb86 	bl	10001788 <XMC_UART_CH_GetReceivedData>
1000207c:	1c03      	adds	r3, r0, #0
1000207e:	b2db      	uxtb	r3, r3
10002080:	7023      	strb	r3, [r4, #0]
        (ptr_runtime->rx_data_index)++;
10002082:	68fb      	ldr	r3, [r7, #12]
10002084:	695b      	ldr	r3, [r3, #20]
10002086:	1c5a      	adds	r2, r3, #1
10002088:	68fb      	ldr	r3, [r7, #12]
1000208a:	615a      	str	r2, [r3, #20]
      }

      if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
1000208c:	68fb      	ldr	r3, [r7, #12]
1000208e:	695a      	ldr	r2, [r3, #20]
10002090:	68fb      	ldr	r3, [r7, #12]
10002092:	691b      	ldr	r3, [r3, #16]
10002094:	429a      	cmp	r2, r3
10002096:	d115      	bne.n	100020c4 <UART_lReceiveHandler+0x84>
      {
        /*Reception complete*/
        ptr_runtime->rx_busy = false;
10002098:	68fb      	ldr	r3, [r7, #12]
1000209a:	2200      	movs	r2, #0
1000209c:	765a      	strb	r2, [r3, #25]
        /*Disable both standard receive and alternative receive FIFO events*/
        XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
1000209e:	687b      	ldr	r3, [r7, #4]
100020a0:	681a      	ldr	r2, [r3, #0]
100020a2:	23c0      	movs	r3, #192	; 0xc0
100020a4:	05db      	lsls	r3, r3, #23
100020a6:	1c10      	adds	r0, r2, #0
100020a8:	1c19      	adds	r1, r3, #0
100020aa:	f7ff fddd 	bl	10001c68 <XMC_USIC_CH_RXFIFO_DisableEvent>
            (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
        if (handle->config->rx_cbhandler != NULL)
100020ae:	687b      	ldr	r3, [r7, #4]
100020b0:	685b      	ldr	r3, [r3, #4]
100020b2:	68db      	ldr	r3, [r3, #12]
100020b4:	2b00      	cmp	r3, #0
100020b6:	d004      	beq.n	100020c2 <UART_lReceiveHandler+0x82>
        {
          /*Execute the 'End of reception' callback function*/
          handle->config->rx_cbhandler();
100020b8:	687b      	ldr	r3, [r7, #4]
100020ba:	685b      	ldr	r3, [r3, #4]
100020bc:	68db      	ldr	r3, [r3, #12]
100020be:	4798      	blx	r3
        }
        break;
100020c0:	e00c      	b.n	100020dc <UART_lReceiveHandler+0x9c>
100020c2:	e00b      	b.n	100020dc <UART_lReceiveHandler+0x9c>
  UART_RUNTIME_t * ptr_runtime = handle->runtime;

  if (handle->config->rx_fifo_size != XMC_USIC_CH_FIFO_DISABLED)
  {
    /*When Receive FIFO is enabled*/
    while (XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel) == false)
100020c4:	687b      	ldr	r3, [r7, #4]
100020c6:	681b      	ldr	r3, [r3, #0]
100020c8:	1c18      	adds	r0, r3, #0
100020ca:	f7ff fdef 	bl	10001cac <XMC_USIC_CH_RXFIFO_IsEmpty>
100020ce:	1c03      	adds	r3, r0, #0
100020d0:	1c1a      	adds	r2, r3, #0
100020d2:	2301      	movs	r3, #1
100020d4:	4053      	eors	r3, r2
100020d6:	b2db      	uxtb	r3, r3
100020d8:	2b00      	cmp	r3, #0
100020da:	d1bf      	bne.n	1000205c <UART_lReceiveHandler+0x1c>
        }
        break;
      }
    }
    /*Set the trigger limit if data still to be received*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
100020dc:	68fb      	ldr	r3, [r7, #12]
100020de:	695a      	ldr	r2, [r3, #20]
100020e0:	68fb      	ldr	r3, [r7, #12]
100020e2:	691b      	ldr	r3, [r3, #16]
100020e4:	429a      	cmp	r2, r3
100020e6:	d23c      	bcs.n	10002162 <UART_lReceiveHandler+0x122>
    {
      UART_lReconfigureRxFIFO(handle,
          (uint32_t)(ptr_runtime->rx_data_count - ptr_runtime->rx_data_index));
100020e8:	68fb      	ldr	r3, [r7, #12]
100020ea:	691a      	ldr	r2, [r3, #16]
100020ec:	68fb      	ldr	r3, [r7, #12]
100020ee:	695b      	ldr	r3, [r3, #20]
      }
    }
    /*Set the trigger limit if data still to be received*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
    {
      UART_lReconfigureRxFIFO(handle,
100020f0:	1ad3      	subs	r3, r2, r3
100020f2:	687a      	ldr	r2, [r7, #4]
100020f4:	1c10      	adds	r0, r2, #0
100020f6:	1c19      	adds	r1, r3, #0
100020f8:	f000 f836 	bl	10002168 <UART_lReconfigureRxFIFO>
100020fc:	e031      	b.n	10002162 <UART_lReceiveHandler+0x122>
    }
  }
  else
  {
    /*When RxFIFO is disabled*/
    if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
100020fe:	68fb      	ldr	r3, [r7, #12]
10002100:	695a      	ldr	r2, [r3, #20]
10002102:	68fb      	ldr	r3, [r7, #12]
10002104:	691b      	ldr	r3, [r3, #16]
10002106:	429a      	cmp	r2, r3
10002108:	d211      	bcs.n	1000212e <UART_lReceiveHandler+0xee>
    {
      ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)XMC_UART_CH_GetReceivedData(handle->channel);
1000210a:	68fb      	ldr	r3, [r7, #12]
1000210c:	685a      	ldr	r2, [r3, #4]
1000210e:	68fb      	ldr	r3, [r7, #12]
10002110:	695b      	ldr	r3, [r3, #20]
10002112:	18d4      	adds	r4, r2, r3
10002114:	687b      	ldr	r3, [r7, #4]
10002116:	681b      	ldr	r3, [r3, #0]
10002118:	1c18      	adds	r0, r3, #0
1000211a:	f7ff fb35 	bl	10001788 <XMC_UART_CH_GetReceivedData>
1000211e:	1c03      	adds	r3, r0, #0
10002120:	b2db      	uxtb	r3, r3
10002122:	7023      	strb	r3, [r4, #0]
      (ptr_runtime->rx_data_index)++;
10002124:	68fb      	ldr	r3, [r7, #12]
10002126:	695b      	ldr	r3, [r3, #20]
10002128:	1c5a      	adds	r2, r3, #1
1000212a:	68fb      	ldr	r3, [r7, #12]
1000212c:	615a      	str	r2, [r3, #20]
    }

    if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
1000212e:	68fb      	ldr	r3, [r7, #12]
10002130:	695a      	ldr	r2, [r3, #20]
10002132:	68fb      	ldr	r3, [r7, #12]
10002134:	691b      	ldr	r3, [r3, #16]
10002136:	429a      	cmp	r2, r3
10002138:	d113      	bne.n	10002162 <UART_lReceiveHandler+0x122>
    {
      /*Reception complete*/
      ptr_runtime->rx_busy = false;
1000213a:	68fb      	ldr	r3, [r7, #12]
1000213c:	2200      	movs	r2, #0
1000213e:	765a      	strb	r2, [r3, #25]
      /*Disable both standard receive and alternative receive FIFO events*/
      XMC_USIC_CH_DisableEvent(handle->channel,
10002140:	687b      	ldr	r3, [r7, #4]
10002142:	681a      	ldr	r2, [r3, #0]
10002144:	23c0      	movs	r3, #192	; 0xc0
10002146:	021b      	lsls	r3, r3, #8
10002148:	1c10      	adds	r0, r2, #0
1000214a:	1c19      	adds	r1, r3, #0
1000214c:	f7ff fcf2 	bl	10001b34 <XMC_USIC_CH_DisableEvent>
          (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE | (uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE));

      if (handle->config->rx_cbhandler != NULL)
10002150:	687b      	ldr	r3, [r7, #4]
10002152:	685b      	ldr	r3, [r3, #4]
10002154:	68db      	ldr	r3, [r3, #12]
10002156:	2b00      	cmp	r3, #0
10002158:	d003      	beq.n	10002162 <UART_lReceiveHandler+0x122>
      {
        /*Execute the 'End of reception' callback function*/
        handle->config->rx_cbhandler();
1000215a:	687b      	ldr	r3, [r7, #4]
1000215c:	685b      	ldr	r3, [r3, #4]
1000215e:	68db      	ldr	r3, [r3, #12]
10002160:	4798      	blx	r3
      }
    }
  }
}
10002162:	46bd      	mov	sp, r7
10002164:	b005      	add	sp, #20
10002166:	bd90      	pop	{r4, r7, pc}

10002168 <UART_lReconfigureRxFIFO>:
 * param[in] uint8_t  number of bytes to be received.
 *
 * return void.
 */
static void UART_lReconfigureRxFIFO(const UART_t * const handle, uint32_t data_size)
{
10002168:	b580      	push	{r7, lr}
1000216a:	b084      	sub	sp, #16
1000216c:	af00      	add	r7, sp, #0
1000216e:	6078      	str	r0, [r7, #4]
10002170:	6039      	str	r1, [r7, #0]
  uint32_t fifo_size;
  uint32_t ret_limit_val = 0U;
10002172:	2300      	movs	r3, #0
10002174:	60fb      	str	r3, [r7, #12]

  /*Get FIFO size in bytes*/
  fifo_size = (uint32_t)(0x01UL << (uint8_t)(handle->config->rx_fifo_size));
10002176:	687b      	ldr	r3, [r7, #4]
10002178:	685b      	ldr	r3, [r3, #4]
1000217a:	222c      	movs	r2, #44	; 0x2c
1000217c:	5c9b      	ldrb	r3, [r3, r2]
1000217e:	1c1a      	adds	r2, r3, #0
10002180:	2301      	movs	r3, #1
10002182:	4093      	lsls	r3, r2
10002184:	60bb      	str	r3, [r7, #8]
  /*If data size is more than FIFO size, configure the limit to the FIFO size*/
  if (data_size < fifo_size)
10002186:	683a      	ldr	r2, [r7, #0]
10002188:	68bb      	ldr	r3, [r7, #8]
1000218a:	429a      	cmp	r2, r3
1000218c:	d203      	bcs.n	10002196 <UART_lReconfigureRxFIFO+0x2e>
  {
    ret_limit_val = (uint32_t)(data_size - 1U);
1000218e:	683b      	ldr	r3, [r7, #0]
10002190:	3b01      	subs	r3, #1
10002192:	60fb      	str	r3, [r7, #12]
10002194:	e002      	b.n	1000219c <UART_lReconfigureRxFIFO+0x34>
  }
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
10002196:	68bb      	ldr	r3, [r7, #8]
10002198:	3b01      	subs	r3, #1
1000219a:	60fb      	str	r3, [r7, #12]
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
1000219c:	687b      	ldr	r3, [r7, #4]
1000219e:	6819      	ldr	r1, [r3, #0]
        handle->config->rx_fifo_size, ret_limit_val);
100021a0:	687b      	ldr	r3, [r7, #4]
100021a2:	685b      	ldr	r3, [r3, #4]
  else
  {
    ret_limit_val = (uint32_t)(fifo_size - 1U);
  }
  /*Set the limit value*/
  XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel,
100021a4:	222c      	movs	r2, #44	; 0x2c
100021a6:	5c9a      	ldrb	r2, [r3, r2]
100021a8:	68fb      	ldr	r3, [r7, #12]
100021aa:	1c08      	adds	r0, r1, #0
100021ac:	1c11      	adds	r1, r2, #0
100021ae:	1c1a      	adds	r2, r3, #0
100021b0:	f7ff fc08 	bl	100019c4 <XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit>
        handle->config->rx_fifo_size, ret_limit_val);
}
100021b4:	46bd      	mov	sp, r7
100021b6:	b004      	add	sp, #16
100021b8:	bd80      	pop	{r7, pc}
100021ba:	46c0      	nop			; (mov r8, r8)

100021bc <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
100021bc:	b580      	push	{r7, lr}
100021be:	b082      	sub	sp, #8
100021c0:	af00      	add	r7, sp, #0
100021c2:	1c02      	adds	r2, r0, #0
100021c4:	1dfb      	adds	r3, r7, #7
100021c6:	701a      	strb	r2, [r3, #0]
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
100021c8:	4b06      	ldr	r3, [pc, #24]	; (100021e4 <NVIC_EnableIRQ+0x28>)
100021ca:	1dfa      	adds	r2, r7, #7
100021cc:	7812      	ldrb	r2, [r2, #0]
100021ce:	1c11      	adds	r1, r2, #0
100021d0:	221f      	movs	r2, #31
100021d2:	400a      	ands	r2, r1
100021d4:	2101      	movs	r1, #1
100021d6:	4091      	lsls	r1, r2
100021d8:	1c0a      	adds	r2, r1, #0
100021da:	601a      	str	r2, [r3, #0]
}
100021dc:	46bd      	mov	sp, r7
100021de:	b002      	add	sp, #8
100021e0:	bd80      	pop	{r7, pc}
100021e2:	46c0      	nop			; (mov r8, r8)
100021e4:	e000e100 	.word	0xe000e100

100021e8 <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
100021e8:	b5b0      	push	{r4, r5, r7, lr}
100021ea:	b082      	sub	sp, #8
100021ec:	af00      	add	r7, sp, #0
100021ee:	1c02      	adds	r2, r0, #0
100021f0:	6039      	str	r1, [r7, #0]
100021f2:	1dfb      	adds	r3, r7, #7
100021f4:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) < 0)
100021f6:	1dfb      	adds	r3, r7, #7
100021f8:	781b      	ldrb	r3, [r3, #0]
100021fa:	2b7f      	cmp	r3, #127	; 0x7f
100021fc:	d92f      	bls.n	1000225e <NVIC_SetPriority+0x76>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100021fe:	4c2d      	ldr	r4, [pc, #180]	; (100022b4 <NVIC_SetPriority+0xcc>)
10002200:	1dfb      	adds	r3, r7, #7
10002202:	781b      	ldrb	r3, [r3, #0]
10002204:	1c1a      	adds	r2, r3, #0
10002206:	230f      	movs	r3, #15
10002208:	4013      	ands	r3, r2
1000220a:	3b08      	subs	r3, #8
1000220c:	0899      	lsrs	r1, r3, #2
1000220e:	4a29      	ldr	r2, [pc, #164]	; (100022b4 <NVIC_SetPriority+0xcc>)
10002210:	1dfb      	adds	r3, r7, #7
10002212:	781b      	ldrb	r3, [r3, #0]
10002214:	1c18      	adds	r0, r3, #0
10002216:	230f      	movs	r3, #15
10002218:	4003      	ands	r3, r0
1000221a:	3b08      	subs	r3, #8
1000221c:	089b      	lsrs	r3, r3, #2
1000221e:	3306      	adds	r3, #6
10002220:	009b      	lsls	r3, r3, #2
10002222:	18d3      	adds	r3, r2, r3
10002224:	685b      	ldr	r3, [r3, #4]
10002226:	1dfa      	adds	r2, r7, #7
10002228:	7812      	ldrb	r2, [r2, #0]
1000222a:	1c10      	adds	r0, r2, #0
1000222c:	2203      	movs	r2, #3
1000222e:	4002      	ands	r2, r0
10002230:	00d2      	lsls	r2, r2, #3
10002232:	1c10      	adds	r0, r2, #0
10002234:	22ff      	movs	r2, #255	; 0xff
10002236:	4082      	lsls	r2, r0
10002238:	43d2      	mvns	r2, r2
1000223a:	401a      	ands	r2, r3
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
1000223c:	683b      	ldr	r3, [r7, #0]
1000223e:	019b      	lsls	r3, r3, #6
10002240:	20ff      	movs	r0, #255	; 0xff
10002242:	4003      	ands	r3, r0
10002244:	1df8      	adds	r0, r7, #7
10002246:	7800      	ldrb	r0, [r0, #0]
10002248:	1c05      	adds	r5, r0, #0
1000224a:	2003      	movs	r0, #3
1000224c:	4028      	ands	r0, r5
1000224e:	00c0      	lsls	r0, r0, #3
10002250:	4083      	lsls	r3, r0
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10002252:	431a      	orrs	r2, r3
10002254:	1d8b      	adds	r3, r1, #6
10002256:	009b      	lsls	r3, r3, #2
10002258:	18e3      	adds	r3, r4, r3
1000225a:	605a      	str	r2, [r3, #4]
1000225c:	e026      	b.n	100022ac <NVIC_SetPriority+0xc4>
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1000225e:	4c16      	ldr	r4, [pc, #88]	; (100022b8 <NVIC_SetPriority+0xd0>)
10002260:	1dfb      	adds	r3, r7, #7
10002262:	781b      	ldrb	r3, [r3, #0]
10002264:	b25b      	sxtb	r3, r3
10002266:	089b      	lsrs	r3, r3, #2
10002268:	4913      	ldr	r1, [pc, #76]	; (100022b8 <NVIC_SetPriority+0xd0>)
1000226a:	1dfa      	adds	r2, r7, #7
1000226c:	7812      	ldrb	r2, [r2, #0]
1000226e:	b252      	sxtb	r2, r2
10002270:	0892      	lsrs	r2, r2, #2
10002272:	32c0      	adds	r2, #192	; 0xc0
10002274:	0092      	lsls	r2, r2, #2
10002276:	5852      	ldr	r2, [r2, r1]
10002278:	1df9      	adds	r1, r7, #7
1000227a:	7809      	ldrb	r1, [r1, #0]
1000227c:	1c08      	adds	r0, r1, #0
1000227e:	2103      	movs	r1, #3
10002280:	4001      	ands	r1, r0
10002282:	00c9      	lsls	r1, r1, #3
10002284:	1c08      	adds	r0, r1, #0
10002286:	21ff      	movs	r1, #255	; 0xff
10002288:	4081      	lsls	r1, r0
1000228a:	43c9      	mvns	r1, r1
1000228c:	4011      	ands	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
1000228e:	683a      	ldr	r2, [r7, #0]
10002290:	0192      	lsls	r2, r2, #6
10002292:	20ff      	movs	r0, #255	; 0xff
10002294:	4002      	ands	r2, r0
10002296:	1df8      	adds	r0, r7, #7
10002298:	7800      	ldrb	r0, [r0, #0]
1000229a:	1c05      	adds	r5, r0, #0
1000229c:	2003      	movs	r0, #3
1000229e:	4028      	ands	r0, r5
100022a0:	00c0      	lsls	r0, r0, #3
100022a2:	4082      	lsls	r2, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100022a4:	430a      	orrs	r2, r1
100022a6:	33c0      	adds	r3, #192	; 0xc0
100022a8:	009b      	lsls	r3, r3, #2
100022aa:	511a      	str	r2, [r3, r4]
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
100022ac:	46bd      	mov	sp, r7
100022ae:	b002      	add	sp, #8
100022b0:	bdb0      	pop	{r4, r5, r7, pc}
100022b2:	46c0      	nop			; (mov r8, r8)
100022b4:	e000ed00 	.word	0xe000ed00
100022b8:	e000e100 	.word	0xe000e100

100022bc <XMC_USIC_CH_SetInputSource>:
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
100022bc:	b580      	push	{r7, lr}
100022be:	b082      	sub	sp, #8
100022c0:	af00      	add	r7, sp, #0
100022c2:	6078      	str	r0, [r7, #4]
100022c4:	1c08      	adds	r0, r1, #0
100022c6:	1c11      	adds	r1, r2, #0
100022c8:	1cfb      	adds	r3, r7, #3
100022ca:	1c02      	adds	r2, r0, #0
100022cc:	701a      	strb	r2, [r3, #0]
100022ce:	1cbb      	adds	r3, r7, #2
100022d0:	1c0a      	adds	r2, r1, #0
100022d2:	701a      	strb	r2, [r3, #0]
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
100022d4:	1cfb      	adds	r3, r7, #3
100022d6:	7818      	ldrb	r0, [r3, #0]
100022d8:	1cfb      	adds	r3, r7, #3
100022da:	781b      	ldrb	r3, [r3, #0]
100022dc:	687a      	ldr	r2, [r7, #4]
100022de:	3306      	adds	r3, #6
100022e0:	009b      	lsls	r3, r3, #2
100022e2:	18d3      	adds	r3, r2, r3
100022e4:	685b      	ldr	r3, [r3, #4]
100022e6:	2207      	movs	r2, #7
100022e8:	4393      	bics	r3, r2
100022ea:	1c1a      	adds	r2, r3, #0
                         ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
100022ec:	1cbb      	adds	r3, r7, #2
100022ee:	781b      	ldrb	r3, [r3, #0]
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
100022f0:	431a      	orrs	r2, r3
100022f2:	6879      	ldr	r1, [r7, #4]
100022f4:	1d83      	adds	r3, r0, #6
100022f6:	009b      	lsls	r3, r3, #2
100022f8:	18cb      	adds	r3, r1, r3
100022fa:	605a      	str	r2, [r3, #4]
                         ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
}
100022fc:	46bd      	mov	sp, r7
100022fe:	b002      	add	sp, #8
10002300:	bd80      	pop	{r7, pc}
10002302:	46c0      	nop			; (mov r8, r8)

10002304 <XMC_UART_CH_Start>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_UART_CH_Stop(), XMC_UART_CH_Transmit()\n\n\n
 */
__STATIC_INLINE void XMC_UART_CH_Start(XMC_USIC_CH_t *const channel)
{
10002304:	b580      	push	{r7, lr}
10002306:	b082      	sub	sp, #8
10002308:	af00      	add	r7, sp, #0
1000230a:	6078      	str	r0, [r7, #4]
  channel->CCR = (uint32_t)(((channel->CCR) & (~USIC_CH_CCR_MODE_Msk)) | (uint32_t)XMC_USIC_CH_OPERATING_MODE_UART);
1000230c:	687b      	ldr	r3, [r7, #4]
1000230e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
10002310:	220f      	movs	r2, #15
10002312:	4393      	bics	r3, r2
10002314:	2202      	movs	r2, #2
10002316:	431a      	orrs	r2, r3
10002318:	687b      	ldr	r3, [r7, #4]
1000231a:	641a      	str	r2, [r3, #64]	; 0x40
}
1000231c:	46bd      	mov	sp, r7
1000231e:	b002      	add	sp, #8
10002320:	bd80      	pop	{r7, pc}
10002322:	46c0      	nop			; (mov r8, r8)

10002324 <UART_0_init>:
/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
/*Channel initialization function*/
UART_STATUS_t UART_0_init()
{
10002324:	b580      	push	{r7, lr}
10002326:	b082      	sub	sp, #8
10002328:	af00      	add	r7, sp, #0
  UART_STATUS_t status = UART_STATUS_SUCCESS;
1000232a:	1dfb      	adds	r3, r7, #7
1000232c:	2200      	movs	r2, #0
1000232e:	701a      	strb	r2, [r3, #0]
  /*Configure Receive pin*/
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, 2U, &UART_0_rx_pin_config);
10002330:	4a37      	ldr	r2, [pc, #220]	; (10002410 <UART_0_init+0xec>)
10002332:	4b38      	ldr	r3, [pc, #224]	; (10002414 <UART_0_init+0xf0>)
10002334:	1c10      	adds	r0, r2, #0
10002336:	2102      	movs	r1, #2
10002338:	1c1a      	adds	r2, r3, #0
1000233a:	f7fe feeb 	bl	10001114 <XMC_GPIO_Init>
  /* Initialize USIC channel in UART mode*/
  XMC_UART_CH_Init(XMC_UART0_CH0, &UART_0_channel_config);
1000233e:	2390      	movs	r3, #144	; 0x90
10002340:	05da      	lsls	r2, r3, #23
10002342:	4b35      	ldr	r3, [pc, #212]	; (10002418 <UART_0_init+0xf4>)
10002344:	1c10      	adds	r0, r2, #0
10002346:	1c19      	adds	r1, r3, #0
10002348:	f7ff f996 	bl	10001678 <XMC_UART_CH_Init>
  /*Set input source path*/
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH0, XMC_USIC_CH_INPUT_DX0, 6U);
1000234c:	2390      	movs	r3, #144	; 0x90
1000234e:	05db      	lsls	r3, r3, #23
10002350:	1c18      	adds	r0, r3, #0
10002352:	2100      	movs	r1, #0
10002354:	2206      	movs	r2, #6
10002356:	f7ff ffb1 	bl	100022bc <XMC_USIC_CH_SetInputSource>
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH0, XMC_USIC_CH_INPUT_DX3, 0U);
1000235a:	2390      	movs	r3, #144	; 0x90
1000235c:	05db      	lsls	r3, r3, #23
1000235e:	1c18      	adds	r0, r3, #0
10002360:	2103      	movs	r1, #3
10002362:	2200      	movs	r2, #0
10002364:	f7ff ffaa 	bl	100022bc <XMC_USIC_CH_SetInputSource>
  XMC_USIC_CH_SetInputSource(XMC_UART0_CH0, XMC_USIC_CH_INPUT_DX5, 0U);
10002368:	2390      	movs	r3, #144	; 0x90
1000236a:	05db      	lsls	r3, r3, #23
1000236c:	1c18      	adds	r0, r3, #0
1000236e:	2105      	movs	r1, #5
10002370:	2200      	movs	r2, #0
10002372:	f7ff ffa3 	bl	100022bc <XMC_USIC_CH_SetInputSource>
  /*Configure transmit FIFO*/
  XMC_USIC_CH_TXFIFO_Configure(XMC_UART0_CH0,
10002376:	2390      	movs	r3, #144	; 0x90
10002378:	05db      	lsls	r3, r3, #23
1000237a:	1c18      	adds	r0, r3, #0
1000237c:	2110      	movs	r1, #16
1000237e:	2204      	movs	r2, #4
10002380:	2301      	movs	r3, #1
10002382:	f7ff fabf 	bl	10001904 <XMC_USIC_CH_TXFIFO_Configure>
        16U,
        XMC_USIC_CH_FIFO_SIZE_16WORDS,
        1U);
  /*Configure receive FIFO*/
  XMC_USIC_CH_RXFIFO_Configure(XMC_UART0_CH0,
10002386:	2390      	movs	r3, #144	; 0x90
10002388:	05db      	lsls	r3, r3, #23
1000238a:	1c18      	adds	r0, r3, #0
1000238c:	2100      	movs	r1, #0
1000238e:	2204      	movs	r2, #4
10002390:	2300      	movs	r3, #0
10002392:	f7ff fae5 	bl	10001960 <XMC_USIC_CH_RXFIFO_Configure>
        0U,
        XMC_USIC_CH_FIFO_SIZE_16WORDS,
        0U);
  /* Start UART */
  XMC_UART_CH_Start(XMC_UART0_CH0);
10002396:	2390      	movs	r3, #144	; 0x90
10002398:	05db      	lsls	r3, r3, #23
1000239a:	1c18      	adds	r0, r3, #0
1000239c:	f7ff ffb2 	bl	10002304 <XMC_UART_CH_Start>

  /* Initialize UART TX pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, 1U, &UART_0_tx_pin_config);
100023a0:	4a1b      	ldr	r2, [pc, #108]	; (10002410 <UART_0_init+0xec>)
100023a2:	4b1e      	ldr	r3, [pc, #120]	; (1000241c <UART_0_init+0xf8>)
100023a4:	1c10      	adds	r0, r2, #0
100023a6:	2101      	movs	r1, #1
100023a8:	1c1a      	adds	r2, r3, #0
100023aa:	f7fe feb3 	bl	10001114 <XMC_GPIO_Init>

  /*Set service request for UART protocol events*/
  XMC_USIC_CH_SetInterruptNodePointer(XMC_UART0_CH0, XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
100023ae:	2390      	movs	r3, #144	; 0x90
100023b0:	05db      	lsls	r3, r3, #23
100023b2:	1c18      	adds	r0, r3, #0
100023b4:	2110      	movs	r1, #16
100023b6:	2200      	movs	r2, #0
100023b8:	f7ff fb32 	bl	10001a20 <XMC_USIC_CH_SetInterruptNodePointer>
     0U);
  /*Set service request for tx FIFO transmit interrupt*/
  XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_UART0_CH0, XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
100023bc:	2390      	movs	r3, #144	; 0x90
100023be:	05db      	lsls	r3, r3, #23
100023c0:	1c18      	adds	r0, r3, #0
100023c2:	2110      	movs	r1, #16
100023c4:	2202      	movs	r2, #2
100023c6:	f7ff fb4b 	bl	10001a60 <XMC_USIC_CH_TXFIFO_SetInterruptNodePointer>
      2U);
  /*Set service request for rx FIFO receive interrupt*/
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART0_CH0, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
100023ca:	2390      	movs	r3, #144	; 0x90
100023cc:	05db      	lsls	r3, r3, #23
100023ce:	1c18      	adds	r0, r3, #0
100023d0:	2110      	movs	r1, #16
100023d2:	2201      	movs	r2, #1
100023d4:	f7ff fb68 	bl	10001aa8 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
       0x1U);
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART0_CH0, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE,
100023d8:	2390      	movs	r3, #144	; 0x90
100023da:	05db      	lsls	r3, r3, #23
100023dc:	1c18      	adds	r0, r3, #0
100023de:	2113      	movs	r1, #19
100023e0:	2201      	movs	r2, #1
100023e2:	f7ff fb61 	bl	10001aa8 <XMC_USIC_CH_RXFIFO_SetInterruptNodePointer>
       0x1U);
  /*Set priority and enable NVIC node for transmit interrupt*/
  NVIC_SetPriority((IRQn_Type)11, 3U);
100023e6:	200b      	movs	r0, #11
100023e8:	2103      	movs	r1, #3
100023ea:	f7ff fefd 	bl	100021e8 <NVIC_SetPriority>
  NVIC_EnableIRQ((IRQn_Type)11);
100023ee:	200b      	movs	r0, #11
100023f0:	f7ff fee4 	bl	100021bc <NVIC_EnableIRQ>
  /*Set priority and enable NVIC node for receive interrupt*/
  NVIC_SetPriority((IRQn_Type)10, 3U);
100023f4:	200a      	movs	r0, #10
100023f6:	2103      	movs	r1, #3
100023f8:	f7ff fef6 	bl	100021e8 <NVIC_SetPriority>
  NVIC_EnableIRQ((IRQn_Type)10);
100023fc:	200a      	movs	r0, #10
100023fe:	f7ff fedd 	bl	100021bc <NVIC_EnableIRQ>
  return status;
10002402:	1dfb      	adds	r3, r7, #7
10002404:	781b      	ldrb	r3, [r3, #0]
}
10002406:	1c18      	adds	r0, r3, #0
10002408:	46bd      	mov	sp, r7
1000240a:	b002      	add	sp, #8
1000240c:	bd80      	pop	{r7, pc}
1000240e:	46c0      	nop			; (mov r8, r8)
10002410:	40040200 	.word	0x40040200
10002414:	10002cc4 	.word	0x10002cc4
10002418:	10002c74 	.word	0x10002c74
1000241c:	10002c80 	.word	0x10002c80

10002420 <USIC0_2_IRQHandler>:
/*Interrupt handlers*/
/*Transmit ISR*/
void UART_0_TX_HANDLER()
{
10002420:	b580      	push	{r7, lr}
10002422:	af00      	add	r7, sp, #0
  UART_lTransmitHandler(&UART_0);
10002424:	4b02      	ldr	r3, [pc, #8]	; (10002430 <USIC0_2_IRQHandler+0x10>)
10002426:	1c18      	adds	r0, r3, #0
10002428:	f7ff fd82 	bl	10001f30 <UART_lTransmitHandler>
}
1000242c:	46bd      	mov	sp, r7
1000242e:	bd80      	pop	{r7, pc}
10002430:	20000520 	.word	0x20000520

10002434 <USIC0_1_IRQHandler>:

/*Receive ISR*/
void UART_0_RX_HANDLER()
{
10002434:	b580      	push	{r7, lr}
10002436:	af00      	add	r7, sp, #0
  UART_lReceiveHandler(&UART_0);
10002438:	4b02      	ldr	r3, [pc, #8]	; (10002444 <USIC0_1_IRQHandler+0x10>)
1000243a:	1c18      	adds	r0, r3, #0
1000243c:	f7ff fe00 	bl	10002040 <UART_lReceiveHandler>
}
10002440:	46bd      	mov	sp, r7
10002442:	bd80      	pop	{r7, pc}
10002444:	20000520 	.word	0x20000520

10002448 <XMC_CCU4_EnableClock>:
 *
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_DisableClock()<BR> XMC_CCU4_EnableMultipleClocks()<BR> XMC_CCU4_StartPrescaler()<BR> XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
10002448:	b580      	push	{r7, lr}
1000244a:	b082      	sub	sp, #8
1000244c:	af00      	add	r7, sp, #0
1000244e:	6078      	str	r0, [r7, #4]
10002450:	1c0a      	adds	r2, r1, #0
10002452:	1cfb      	adds	r3, r7, #3
10002454:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1) << slice_number;
10002456:	687b      	ldr	r3, [r7, #4]
10002458:	68da      	ldr	r2, [r3, #12]
1000245a:	1cfb      	adds	r3, r7, #3
1000245c:	781b      	ldrb	r3, [r3, #0]
1000245e:	2101      	movs	r1, #1
10002460:	4099      	lsls	r1, r3
10002462:	1c0b      	adds	r3, r1, #0
10002464:	431a      	orrs	r2, r3
10002466:	687b      	ldr	r3, [r7, #4]
10002468:	60da      	str	r2, [r3, #12]
}
1000246a:	46bd      	mov	sp, r7
1000246c:	b002      	add	sp, #8
1000246e:	bd80      	pop	{r7, pc}

10002470 <XMC_CCU4_SLICE_StartTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
10002470:	b580      	push	{r7, lr}
10002472:	b082      	sub	sp, #8
10002474:	af00      	add	r7, sp, #0
10002476:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
10002478:	687b      	ldr	r3, [r7, #4]
1000247a:	2201      	movs	r2, #1
1000247c:	60da      	str	r2, [r3, #12]
}
1000247e:	46bd      	mov	sp, r7
10002480:	b002      	add	sp, #8
10002482:	bd80      	pop	{r7, pc}

10002484 <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
10002484:	b580      	push	{r7, lr}
10002486:	b082      	sub	sp, #8
10002488:	af00      	add	r7, sp, #0
1000248a:	6078      	str	r0, [r7, #4]
1000248c:	1c0a      	adds	r2, r1, #0
1000248e:	1cbb      	adds	r3, r7, #2
10002490:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
10002492:	1cbb      	adds	r3, r7, #2
10002494:	881a      	ldrh	r2, [r3, #0]
10002496:	687b      	ldr	r3, [r7, #4]
10002498:	635a      	str	r2, [r3, #52]	; 0x34
}
1000249a:	46bd      	mov	sp, r7
1000249c:	b002      	add	sp, #8
1000249e:	bd80      	pop	{r7, pc}

100024a0 <XMC_CCU4_SLICE_SetTimerCompareMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
100024a0:	b580      	push	{r7, lr}
100024a2:	b082      	sub	sp, #8
100024a4:	af00      	add	r7, sp, #0
100024a6:	6078      	str	r0, [r7, #4]
100024a8:	1c0a      	adds	r2, r1, #0
100024aa:	1cbb      	adds	r3, r7, #2
100024ac:	801a      	strh	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
100024ae:	1cbb      	adds	r3, r7, #2
100024b0:	881a      	ldrh	r2, [r3, #0]
100024b2:	687b      	ldr	r3, [r7, #4]
100024b4:	63da      	str	r2, [r3, #60]	; 0x3c
}
100024b6:	46bd      	mov	sp, r7
100024b8:	b002      	add	sp, #8
100024ba:	bd80      	pop	{r7, pc}

100024bc <XMC_CCU4_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
100024bc:	b580      	push	{r7, lr}
100024be:	b082      	sub	sp, #8
100024c0:	af00      	add	r7, sp, #0
100024c2:	6078      	str	r0, [r7, #4]
100024c4:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
100024c6:	687b      	ldr	r3, [r7, #4]
100024c8:	683a      	ldr	r2, [r7, #0]
100024ca:	611a      	str	r2, [r3, #16]
}
100024cc:	46bd      	mov	sp, r7
100024ce:	b002      	add	sp, #8
100024d0:	bd80      	pop	{r7, pc}
100024d2:	46c0      	nop			; (mov r8, r8)

100024d4 <XMC_CCU4_SLICE_EnableEvent>:
 *  XMC_CCU4_SLICE_SetInterruptNode()<BR> XMC_CCU4_SLICE_EnableMultipleEvents()<BR> XMC_CCU4_SLICE_DisableEvent()<BR>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
                                                const XMC_CCU4_SLICE_IRQ_ID_t event)
{
100024d4:	b580      	push	{r7, lr}
100024d6:	b082      	sub	sp, #8
100024d8:	af00      	add	r7, sp, #0
100024da:	6078      	str	r0, [r7, #4]
100024dc:	1c0a      	adds	r2, r1, #0
100024de:	1cfb      	adds	r3, r7, #3
100024e0:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
100024e2:	687b      	ldr	r3, [r7, #4]
100024e4:	22a4      	movs	r2, #164	; 0xa4
100024e6:	589a      	ldr	r2, [r3, r2]
100024e8:	1cfb      	adds	r3, r7, #3
100024ea:	781b      	ldrb	r3, [r3, #0]
100024ec:	2101      	movs	r1, #1
100024ee:	4099      	lsls	r1, r3
100024f0:	1c0b      	adds	r3, r1, #0
100024f2:	431a      	orrs	r2, r3
100024f4:	687b      	ldr	r3, [r7, #4]
100024f6:	21a4      	movs	r1, #164	; 0xa4
100024f8:	505a      	str	r2, [r3, r1]
}
100024fa:	46bd      	mov	sp, r7
100024fc:	b002      	add	sp, #8
100024fe:	bd80      	pop	{r7, pc}

10002500 <PWM_lCCU4_Init>:

#ifdef PWM_SLICE_USED_CCU4

/*Initialize the APP and CCU4 slice. */
PWM_STATUS_t PWM_lCCU4_Init(PWM_t *const handle_ptr)
{
10002500:	b590      	push	{r4, r7, lr}
10002502:	b085      	sub	sp, #20
10002504:	af00      	add	r7, sp, #0
10002506:	6078      	str	r0, [r7, #4]
  PWM_STATUS_t status = PWM_STATUS_FAILURE;
10002508:	230f      	movs	r3, #15
1000250a:	18fb      	adds	r3, r7, r3
1000250c:	2201      	movs	r2, #1
1000250e:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("PWM_lCCU4_Init:Invalid handle_ptr" , (handle_ptr != NULL))

  if (PWM_STATUS_UNINITIALIZED == handle_ptr->state)
10002510:	687b      	ldr	r3, [r7, #4]
10002512:	2229      	movs	r2, #41	; 0x29
10002514:	5c9b      	ldrb	r3, [r3, r2]
10002516:	2b02      	cmp	r3, #2
10002518:	d155      	bne.n	100025c6 <PWM_lCCU4_Init+0xc6>
  {
    /* Initialize consumed Apps */
    status = (PWM_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handle);
1000251a:	687b      	ldr	r3, [r7, #4]
1000251c:	681b      	ldr	r3, [r3, #0]
1000251e:	220f      	movs	r2, #15
10002520:	18bc      	adds	r4, r7, r2
10002522:	1c18      	adds	r0, r3, #0
10002524:	f000 f94a 	bl	100027bc <GLOBAL_CCU4_Init>
10002528:	1c03      	adds	r3, r0, #0
1000252a:	7023      	strb	r3, [r4, #0]

    /*Initialize CCU4 slice */
    if (PWM_STATUS_SUCCESS == status)/*check GLOBAL_CCU4_Init status*/
1000252c:	230f      	movs	r3, #15
1000252e:	18fb      	adds	r3, r7, r3
10002530:	781b      	ldrb	r3, [r3, #0]
10002532:	2b00      	cmp	r3, #0
10002534:	d143      	bne.n	100025be <PWM_lCCU4_Init+0xbe>
    {
      XMC_DEBUG("PWM_lCCU4_Init:Initilizing Slice")
      XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
10002536:	687b      	ldr	r3, [r7, #4]
10002538:	689a      	ldr	r2, [r3, #8]
1000253a:	687b      	ldr	r3, [r7, #4]
1000253c:	68db      	ldr	r3, [r3, #12]
1000253e:	1c10      	adds	r0, r2, #0
10002540:	1c19      	adds	r1, r3, #0
10002542:	f7fe ffff 	bl	10001544 <XMC_CCU4_SLICE_CompareInit>

      /* Set the period and compare register values */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr,
10002546:	687b      	ldr	r3, [r7, #4]
10002548:	689a      	ldr	r2, [r3, #8]
    		                             (uint16_t)handle_ptr->period_value);
1000254a:	687b      	ldr	r3, [r7, #4]
1000254c:	69db      	ldr	r3, [r3, #28]
    {
      XMC_DEBUG("PWM_lCCU4_Init:Initilizing Slice")
      XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);

      /* Set the period and compare register values */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr,
1000254e:	b29b      	uxth	r3, r3
10002550:	1c10      	adds	r0, r2, #0
10002552:	1c19      	adds	r1, r3, #0
10002554:	f7ff ff96 	bl	10002484 <XMC_CCU4_SLICE_SetTimerPeriodMatch>
    		                             (uint16_t)handle_ptr->period_value);

      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr,
10002558:	687b      	ldr	r3, [r7, #4]
1000255a:	689a      	ldr	r2, [r3, #8]
    		                              (uint16_t)handle_ptr->compare_value);
1000255c:	687b      	ldr	r3, [r7, #4]
1000255e:	699b      	ldr	r3, [r3, #24]

      /* Set the period and compare register values */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr,
    		                             (uint16_t)handle_ptr->period_value);

      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr,
10002560:	b29b      	uxth	r3, r3
10002562:	1c10      	adds	r0, r2, #0
10002564:	1c19      	adds	r1, r3, #0
10002566:	f7ff ff9b 	bl	100024a0 <XMC_CCU4_SLICE_SetTimerCompareMatch>
    		                              (uint16_t)handle_ptr->compare_value);

      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_kernel_ptr, handle_ptr->shadow_mask);
1000256a:	687b      	ldr	r3, [r7, #4]
1000256c:	685a      	ldr	r2, [r3, #4]
1000256e:	687b      	ldr	r3, [r7, #4]
10002570:	6a5b      	ldr	r3, [r3, #36]	; 0x24
10002572:	1c10      	adds	r0, r2, #0
10002574:	1c19      	adds	r1, r3, #0
10002576:	f7ff ffa1 	bl	100024bc <XMC_CCU4_EnableShadowTransfer>

      /* Initialize interrupts */
      PWM_lCCU4_ConfigInterrupts(handle_ptr);
1000257a:	687b      	ldr	r3, [r7, #4]
1000257c:	1c18      	adds	r0, r3, #0
1000257e:	f000 f829 	bl	100025d4 <PWM_lCCU4_ConfigInterrupts>

      XMC_GPIO_Init(handle_ptr->gpio_out_port,handle_ptr->gpio_out_pin,
10002582:	687b      	ldr	r3, [r7, #4]
10002584:	6919      	ldr	r1, [r3, #16]
10002586:	687b      	ldr	r3, [r7, #4]
10002588:	222c      	movs	r2, #44	; 0x2c
1000258a:	5c9a      	ldrb	r2, [r3, r2]
1000258c:	687b      	ldr	r3, [r7, #4]
1000258e:	695b      	ldr	r3, [r3, #20]
10002590:	1c08      	adds	r0, r1, #0
10002592:	1c11      	adds	r1, r2, #0
10002594:	1c1a      	adds	r2, r3, #0
10002596:	f7fe fdbd 	bl	10001114 <XMC_GPIO_Init>
    		        handle_ptr->gpio_out_config);

      handle_ptr->state = PWM_STATUS_SUCCESS;
1000259a:	687b      	ldr	r3, [r7, #4]
1000259c:	2229      	movs	r2, #41	; 0x29
1000259e:	2100      	movs	r1, #0
100025a0:	5499      	strb	r1, [r3, r2]

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->start_control)
100025a2:	687b      	ldr	r3, [r7, #4]
100025a4:	222f      	movs	r2, #47	; 0x2f
100025a6:	5c9b      	ldrb	r3, [r3, r2]
100025a8:	2b00      	cmp	r3, #0
100025aa:	d003      	beq.n	100025b4 <PWM_lCCU4_Init+0xb4>
      {
        PWM_Start(handle_ptr);
100025ac:	687b      	ldr	r3, [r7, #4]
100025ae:	1c18      	adds	r0, r3, #0
100025b0:	f000 f8c6 	bl	10002740 <PWM_Start>
      }
      status = PWM_STATUS_SUCCESS;
100025b4:	230f      	movs	r3, #15
100025b6:	18fb      	adds	r3, r7, r3
100025b8:	2200      	movs	r2, #0
100025ba:	701a      	strb	r2, [r3, #0]
100025bc:	e003      	b.n	100025c6 <PWM_lCCU4_Init+0xc6>
    }
    else
    {
      handle_ptr->state = PWM_STATUS_UNINITIALIZED;
100025be:	687b      	ldr	r3, [r7, #4]
100025c0:	2229      	movs	r2, #41	; 0x29
100025c2:	2102      	movs	r1, #2
100025c4:	5499      	strb	r1, [r3, r2]
    }

  }
  return (status);
100025c6:	230f      	movs	r3, #15
100025c8:	18fb      	adds	r3, r7, r3
100025ca:	781b      	ldrb	r3, [r3, #0]
} /* end of PWM_lCCU4_Init() api */
100025cc:	1c18      	adds	r0, r3, #0
100025ce:	46bd      	mov	sp, r7
100025d0:	b005      	add	sp, #20
100025d2:	bd90      	pop	{r4, r7, pc}

100025d4 <PWM_lCCU4_ConfigInterrupts>:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialize interrupts */
void PWM_lCCU4_ConfigInterrupts(PWM_t *const handle_ptr)
{
100025d4:	b580      	push	{r7, lr}
100025d6:	b082      	sub	sp, #8
100025d8:	af00      	add	r7, sp, #0
100025da:	6078      	str	r0, [r7, #4]
  if ((bool) true == handle_ptr->period_match_enable)
100025dc:	687b      	ldr	r3, [r7, #4]
100025de:	2230      	movs	r2, #48	; 0x30
100025e0:	5c9b      	ldrb	r3, [r3, r2]
100025e2:	2b00      	cmp	r3, #0
100025e4:	d00f      	beq.n	10002606 <PWM_lCCU4_ConfigInterrupts+0x32>
  {
    XMC_DEBUG("PWM_lCCU4_ConfigInterrupts:period match enable")
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
100025e6:	687b      	ldr	r3, [r7, #4]
100025e8:	689b      	ldr	r3, [r3, #8]
100025ea:	1c18      	adds	r0, r3, #0
100025ec:	2100      	movs	r1, #0
100025ee:	f7ff ff71 	bl	100024d4 <XMC_CCU4_SLICE_EnableEvent>

    /* Bind event to Service Request Node to period match event*/
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
100025f2:	687b      	ldr	r3, [r7, #4]
100025f4:	6899      	ldr	r1, [r3, #8]
100025f6:	687b      	ldr	r3, [r7, #4]
100025f8:	222a      	movs	r2, #42	; 0x2a
100025fa:	5c9b      	ldrb	r3, [r3, r2]
100025fc:	1c08      	adds	r0, r1, #0
100025fe:	2100      	movs	r1, #0
10002600:	1c1a      	adds	r2, r3, #0
10002602:	f7fe ffd3 	bl	100015ac <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_slice_period_match_node);
  }

  if ((bool) true == handle_ptr->compare_match_enable)
10002606:	687b      	ldr	r3, [r7, #4]
10002608:	2231      	movs	r2, #49	; 0x31
1000260a:	5c9b      	ldrb	r3, [r3, r2]
1000260c:	2b00      	cmp	r3, #0
1000260e:	d00f      	beq.n	10002630 <PWM_lCCU4_ConfigInterrupts+0x5c>
  {
    XMC_DEBUG("PWM_lCCU4_ConfigInterrupts:compare match enable")
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
10002610:	687b      	ldr	r3, [r7, #4]
10002612:	689b      	ldr	r3, [r3, #8]
10002614:	1c18      	adds	r0, r3, #0
10002616:	2102      	movs	r1, #2
10002618:	f7ff ff5c 	bl	100024d4 <XMC_CCU4_SLICE_EnableEvent>

    /* Bind event to Service Request Node to compare match event */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
1000261c:	687b      	ldr	r3, [r7, #4]
1000261e:	6899      	ldr	r1, [r3, #8]
10002620:	687b      	ldr	r3, [r7, #4]
10002622:	222b      	movs	r2, #43	; 0x2b
10002624:	5c9b      	ldrb	r3, [r3, r2]
10002626:	1c08      	adds	r0, r1, #0
10002628:	2102      	movs	r1, #2
1000262a:	1c1a      	adds	r2, r3, #0
1000262c:	f7fe ffbe 	bl	100015ac <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_slice_compare_match_node);
  }
}
10002630:	46bd      	mov	sp, r7
10002632:	b002      	add	sp, #8
10002634:	bd80      	pop	{r7, pc}
10002636:	46c0      	nop			; (mov r8, r8)

10002638 <PWM_lCCU4_Start>:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*Starts the CCU4 slice. */
void PWM_lCCU4_Start(PWM_t *const handle_ptr)
{
10002638:	b580      	push	{r7, lr}
1000263a:	b082      	sub	sp, #8
1000263c:	af00      	add	r7, sp, #0
1000263e:	6078      	str	r0, [r7, #4]
  if ((PWM_STATUS_SUCCESS == handle_ptr->state) || (PWM_STATUS_STOPPED == handle_ptr->state))
10002640:	687b      	ldr	r3, [r7, #4]
10002642:	2229      	movs	r2, #41	; 0x29
10002644:	5c9b      	ldrb	r3, [r3, r2]
10002646:	2b00      	cmp	r3, #0
10002648:	d004      	beq.n	10002654 <PWM_lCCU4_Start+0x1c>
1000264a:	687b      	ldr	r3, [r7, #4]
1000264c:	2229      	movs	r2, #41	; 0x29
1000264e:	5c9b      	ldrb	r3, [r3, r2]
10002650:	2b04      	cmp	r3, #4
10002652:	d111      	bne.n	10002678 <PWM_lCCU4_Start+0x40>
  {
    /* Clears the IDLE mode for the slice */
    XMC_CCU4_EnableClock(handle_ptr->ccu4_kernel_ptr,handle_ptr->slice_number);
10002654:	687b      	ldr	r3, [r7, #4]
10002656:	6859      	ldr	r1, [r3, #4]
10002658:	687b      	ldr	r3, [r7, #4]
1000265a:	222e      	movs	r2, #46	; 0x2e
1000265c:	5c9b      	ldrb	r3, [r3, r2]
1000265e:	1c08      	adds	r0, r1, #0
10002660:	1c19      	adds	r1, r3, #0
10002662:	f7ff fef1 	bl	10002448 <XMC_CCU4_EnableClock>
    XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
10002666:	687b      	ldr	r3, [r7, #4]
10002668:	689b      	ldr	r3, [r3, #8]
1000266a:	1c18      	adds	r0, r3, #0
1000266c:	f7ff ff00 	bl	10002470 <XMC_CCU4_SLICE_StartTimer>

    handle_ptr->state = PWM_STATUS_RUNNING;
10002670:	687b      	ldr	r3, [r7, #4]
10002672:	2229      	movs	r2, #41	; 0x29
10002674:	2103      	movs	r1, #3
10002676:	5499      	strb	r1, [r3, r2]
    XMC_DEBUG("PWM_lCCU4_Start:start PWM")
  }
} /* end of PWM_lCCU4_Start() api */
10002678:	46bd      	mov	sp, r7
1000267a:	b002      	add	sp, #8
1000267c:	bd80      	pop	{r7, pc}
1000267e:	46c0      	nop			; (mov r8, r8)

10002680 <PWM_lCCU4_SetDutyCycle>:
} /* end of PWM_lCCU4_Stop() api */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*Sets the duty cycle for CCU4 slice. */
PWM_STATUS_t PWM_lCCU4_SetDutyCycle(PWM_t *const handle_ptr, uint32_t duty_cycle)
{
10002680:	b580      	push	{r7, lr}
10002682:	b086      	sub	sp, #24
10002684:	af00      	add	r7, sp, #0
10002686:	6078      	str	r0, [r7, #4]
10002688:	6039      	str	r1, [r7, #0]
  uint32_t compare;
  PWM_STATUS_t status;

  XMC_ASSERT("PWM_lCCU4_SetDutyCycle:Invalid duty_cycle " , ((duty_cycle >= 0) && (duty_cycle <= PWM_MAX_DUTY_CYCLE)))

  status = PWM_STATUS_FAILURE;
1000268a:	2317      	movs	r3, #23
1000268c:	18fb      	adds	r3, r7, r3
1000268e:	2201      	movs	r2, #1
10002690:	701a      	strb	r2, [r3, #0]
  if (PWM_STATUS_UNINITIALIZED != handle_ptr->state)
10002692:	687b      	ldr	r3, [r7, #4]
10002694:	2229      	movs	r2, #41	; 0x29
10002696:	5c9b      	ldrb	r3, [r3, r2]
10002698:	2b02      	cmp	r3, #2
1000269a:	d02c      	beq.n	100026f6 <PWM_lCCU4_SetDutyCycle+0x76>
  {
    /* Duty cycle needs between 0 and 10000 */
    if (duty_cycle <= PWM_MAX_DUTY_CYCLE)
1000269c:	683b      	ldr	r3, [r7, #0]
1000269e:	4a19      	ldr	r2, [pc, #100]	; (10002704 <PWM_lCCU4_SetDutyCycle+0x84>)
100026a0:	4293      	cmp	r3, r2
100026a2:	d828      	bhi.n	100026f6 <PWM_lCCU4_SetDutyCycle+0x76>
    {
      /* period = (PR + 1) */
      period = (uint32_t)handle_ptr->period_value + 1U;
100026a4:	687b      	ldr	r3, [r7, #4]
100026a6:	69db      	ldr	r3, [r3, #28]
100026a8:	3301      	adds	r3, #1
100026aa:	613b      	str	r3, [r7, #16]

      /* Duty Cycle(symmetric) = (PR-CR1)+1 / period */
      compare = ((period * (PWM_MAX_DUTY_CYCLE - duty_cycle)) / ((uint32_t) 100 * PWM_DUTY_CYCLE_SCALE));
100026ac:	683b      	ldr	r3, [r7, #0]
100026ae:	4a15      	ldr	r2, [pc, #84]	; (10002704 <PWM_lCCU4_SetDutyCycle+0x84>)
100026b0:	1ad3      	subs	r3, r2, r3
100026b2:	693a      	ldr	r2, [r7, #16]
100026b4:	4353      	muls	r3, r2
100026b6:	1c18      	adds	r0, r3, #0
100026b8:	4912      	ldr	r1, [pc, #72]	; (10002704 <PWM_lCCU4_SetDutyCycle+0x84>)
100026ba:	f000 fa0f 	bl	10002adc <__aeabi_uidiv>
100026be:	1c03      	adds	r3, r0, #0
100026c0:	60fb      	str	r3, [r7, #12]

      handle_ptr->compare_value = compare;
100026c2:	687b      	ldr	r3, [r7, #4]
100026c4:	68fa      	ldr	r2, [r7, #12]
100026c6:	619a      	str	r2, [r3, #24]
      handle_ptr->duty_cycle = duty_cycle;
100026c8:	687b      	ldr	r3, [r7, #4]
100026ca:	683a      	ldr	r2, [r7, #0]
100026cc:	621a      	str	r2, [r3, #32]

      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, (uint16_t)compare);
100026ce:	687b      	ldr	r3, [r7, #4]
100026d0:	689a      	ldr	r2, [r3, #8]
100026d2:	68fb      	ldr	r3, [r7, #12]
100026d4:	b29b      	uxth	r3, r3
100026d6:	1c10      	adds	r0, r2, #0
100026d8:	1c19      	adds	r1, r3, #0
100026da:	f7ff fee1 	bl	100024a0 <XMC_CCU4_SLICE_SetTimerCompareMatch>
      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_kernel_ptr, handle_ptr->shadow_mask);
100026de:	687b      	ldr	r3, [r7, #4]
100026e0:	685a      	ldr	r2, [r3, #4]
100026e2:	687b      	ldr	r3, [r7, #4]
100026e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
100026e6:	1c10      	adds	r0, r2, #0
100026e8:	1c19      	adds	r1, r3, #0
100026ea:	f7ff fee7 	bl	100024bc <XMC_CCU4_EnableShadowTransfer>
      status = PWM_STATUS_SUCCESS;
100026ee:	2317      	movs	r3, #23
100026f0:	18fb      	adds	r3, r7, r3
100026f2:	2200      	movs	r2, #0
100026f4:	701a      	strb	r2, [r3, #0]
    }
  }

  XMC_DEBUG("PWM_lCCU4_SetDutyCycle:dutycycle set")
  return (status);
100026f6:	2317      	movs	r3, #23
100026f8:	18fb      	adds	r3, r7, r3
100026fa:	781b      	ldrb	r3, [r3, #0]
} /* end of PWM_lCCU4_SetDutyCycle() api */
100026fc:	1c18      	adds	r0, r3, #0
100026fe:	46bd      	mov	sp, r7
10002700:	b006      	add	sp, #24
10002702:	bd80      	pop	{r7, pc}
10002704:	00002710 	.word	0x00002710

10002708 <PWM_Init>:
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* This function initializes the app */
PWM_STATUS_t PWM_Init(PWM_t *const handle_ptr)
{
10002708:	b590      	push	{r4, r7, lr}
1000270a:	b085      	sub	sp, #20
1000270c:	af00      	add	r7, sp, #0
1000270e:	6078      	str	r0, [r7, #4]
  PWM_STATUS_t status;
  status = PWM_STATUS_FAILURE;
10002710:	230f      	movs	r3, #15
10002712:	18fb      	adds	r3, r7, r3
10002714:	2201      	movs	r2, #1
10002716:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("PWM_Init:Invalid handle_ptr" , (handle_ptr != NULL))

#ifdef PWM_SLICE_USED_CCU4
  if (PWM_TIMER_SLICE_CCU4 == handle_ptr->timer_type)
10002718:	687b      	ldr	r3, [r7, #4]
1000271a:	2228      	movs	r2, #40	; 0x28
1000271c:	5c9b      	ldrb	r3, [r3, r2]
1000271e:	2b00      	cmp	r3, #0
10002720:	d107      	bne.n	10002732 <PWM_Init+0x2a>
  {
    status = PWM_lCCU4_Init(handle_ptr);
10002722:	230f      	movs	r3, #15
10002724:	18fc      	adds	r4, r7, r3
10002726:	687b      	ldr	r3, [r7, #4]
10002728:	1c18      	adds	r0, r3, #0
1000272a:	f7ff fee9 	bl	10002500 <PWM_lCCU4_Init>
1000272e:	1c03      	adds	r3, r0, #0
10002730:	7023      	strb	r3, [r4, #0]
  {
    status = PWM_lCCU8_Init(handle_ptr);
  }
#endif

  return (status);
10002732:	230f      	movs	r3, #15
10002734:	18fb      	adds	r3, r7, r3
10002736:	781b      	ldrb	r3, [r3, #0]
}
10002738:	1c18      	adds	r0, r3, #0
1000273a:	46bd      	mov	sp, r7
1000273c:	b005      	add	sp, #20
1000273e:	bd90      	pop	{r4, r7, pc}

10002740 <PWM_Start>:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* This function starts the PWM generation. This needs to be called even if external start is configured.*/
void PWM_Start(PWM_t *const handle_ptr)
{
10002740:	b580      	push	{r7, lr}
10002742:	b082      	sub	sp, #8
10002744:	af00      	add	r7, sp, #0
10002746:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("PWM_Start:Invalid handle_ptr" , (handle_ptr != NULL))

#ifdef PWM_SLICE_USED_CCU4
  if (PWM_TIMER_SLICE_CCU4 == handle_ptr->timer_type)
10002748:	687b      	ldr	r3, [r7, #4]
1000274a:	2228      	movs	r2, #40	; 0x28
1000274c:	5c9b      	ldrb	r3, [r3, r2]
1000274e:	2b00      	cmp	r3, #0
10002750:	d103      	bne.n	1000275a <PWM_Start+0x1a>
  {
    PWM_lCCU4_Start(handle_ptr);
10002752:	687b      	ldr	r3, [r7, #4]
10002754:	1c18      	adds	r0, r3, #0
10002756:	f7ff ff6f 	bl	10002638 <PWM_lCCU4_Start>
  if (PWM_TIMER_SLICE_CCU8 == handle_ptr->timer_type)
  {
    PWM_lCCU8_Start(handle_ptr);
  }
#endif
}
1000275a:	46bd      	mov	sp, r7
1000275c:	b002      	add	sp, #8
1000275e:	bd80      	pop	{r7, pc}

10002760 <PWM_SetDutyCycle>:
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/*This function is used to set the duty cycle (uint32_t) of the PWM waveform  */
PWM_STATUS_t PWM_SetDutyCycle(PWM_t *const handle_ptr, uint32_t duty_cycle)
{
10002760:	b590      	push	{r4, r7, lr}
10002762:	b085      	sub	sp, #20
10002764:	af00      	add	r7, sp, #0
10002766:	6078      	str	r0, [r7, #4]
10002768:	6039      	str	r1, [r7, #0]
  PWM_STATUS_t status;
  status = PWM_STATUS_FAILURE;
1000276a:	230f      	movs	r3, #15
1000276c:	18fb      	adds	r3, r7, r3
1000276e:	2201      	movs	r2, #1
10002770:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("PWM_SetDutyCycle:Invalid handle_ptr" , (handle_ptr != NULL))

#ifdef PWM_SLICE_USED_CCU4
  if (PWM_TIMER_SLICE_CCU4 == handle_ptr->timer_type)
10002772:	687b      	ldr	r3, [r7, #4]
10002774:	2228      	movs	r2, #40	; 0x28
10002776:	5c9b      	ldrb	r3, [r3, r2]
10002778:	2b00      	cmp	r3, #0
1000277a:	d109      	bne.n	10002790 <PWM_SetDutyCycle+0x30>
  {
    status = PWM_lCCU4_SetDutyCycle(handle_ptr, duty_cycle);
1000277c:	230f      	movs	r3, #15
1000277e:	18fc      	adds	r4, r7, r3
10002780:	687a      	ldr	r2, [r7, #4]
10002782:	683b      	ldr	r3, [r7, #0]
10002784:	1c10      	adds	r0, r2, #0
10002786:	1c19      	adds	r1, r3, #0
10002788:	f7ff ff7a 	bl	10002680 <PWM_lCCU4_SetDutyCycle>
1000278c:	1c03      	adds	r3, r0, #0
1000278e:	7023      	strb	r3, [r4, #0]
  if (PWM_TIMER_SLICE_CCU8 == handle_ptr->timer_type)
  {
    status = PWM_lCCU8_SetDutyCycle(handle_ptr, duty_cycle);
  }
#endif
  return (status);
10002790:	230f      	movs	r3, #15
10002792:	18fb      	adds	r3, r7, r3
10002794:	781b      	ldrb	r3, [r3, #0]
}
10002796:	1c18      	adds	r0, r3, #0
10002798:	46bd      	mov	sp, r7
1000279a:	b005      	add	sp, #20
1000279c:	bd90      	pop	{r4, r7, pc}
1000279e:	46c0      	nop			; (mov r8, r8)

100027a0 <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
100027a0:	b580      	push	{r7, lr}
100027a2:	b082      	sub	sp, #8
100027a4:	af00      	add	r7, sp, #0
100027a6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
100027a8:	687b      	ldr	r3, [r7, #4]
100027aa:	68db      	ldr	r3, [r3, #12]
100027ac:	2280      	movs	r2, #128	; 0x80
100027ae:	0052      	lsls	r2, r2, #1
100027b0:	431a      	orrs	r2, r3
100027b2:	687b      	ldr	r3, [r7, #4]
100027b4:	60da      	str	r2, [r3, #12]
}
100027b6:	46bd      	mov	sp, r7
100027b8:	b002      	add	sp, #8
100027ba:	bd80      	pop	{r7, pc}

100027bc <GLOBAL_CCU4_Init>:
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
100027bc:	b580      	push	{r7, lr}
100027be:	b082      	sub	sp, #8
100027c0:	af00      	add	r7, sp, #0
100027c2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
100027c4:	687b      	ldr	r3, [r7, #4]
100027c6:	7b5b      	ldrb	r3, [r3, #13]
100027c8:	2201      	movs	r2, #1
100027ca:	4053      	eors	r3, r2
100027cc:	b2db      	uxtb	r3, r3
100027ce:	2b00      	cmp	r3, #0
100027d0:	d00f      	beq.n	100027f2 <GLOBAL_CCU4_Init+0x36>
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
100027d2:	687b      	ldr	r3, [r7, #4]
100027d4:	689a      	ldr	r2, [r3, #8]
100027d6:	687b      	ldr	r3, [r7, #4]
100027d8:	7b1b      	ldrb	r3, [r3, #12]
100027da:	1c10      	adds	r0, r2, #0
100027dc:	1c19      	adds	r1, r3, #0
100027de:	f7fe fe8d 	bl	100014fc <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
100027e2:	687b      	ldr	r3, [r7, #4]
100027e4:	689b      	ldr	r3, [r3, #8]
100027e6:	1c18      	adds	r0, r3, #0
100027e8:	f7ff ffda 	bl	100027a0 <XMC_CCU4_StartPrescaler>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
100027ec:	687b      	ldr	r3, [r7, #4]
100027ee:	2201      	movs	r2, #1
100027f0:	735a      	strb	r2, [r3, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
100027f2:	2300      	movs	r3, #0
}
100027f4:	1c18      	adds	r0, r3, #0
100027f6:	46bd      	mov	sp, r7
100027f8:	b002      	add	sp, #8
100027fa:	bd80      	pop	{r7, pc}

100027fc <SystemCoreSetup>:
{
  .initialized = false
};
 
void SystemCoreSetup(void)
{
100027fc:	b580      	push	{r7, lr}
100027fe:	af00      	add	r7, sp, #0

}
10002800:	46bd      	mov	sp, r7
10002802:	bd80      	pop	{r7, pc}

10002804 <CLOCK_XMC1_Init>:

/*
 * API to initialize the CLOCK_XMC1 APP Interrupts
 */
CLOCK_XMC1_STATUS_t CLOCK_XMC1_Init(CLOCK_XMC1_t *handle)
{
10002804:	b580      	push	{r7, lr}
10002806:	b084      	sub	sp, #16
10002808:	af00      	add	r7, sp, #0
1000280a:	6078      	str	r0, [r7, #4]
  CLOCK_XMC1_STATUS_t status = CLOCK_XMC1_STATUS_SUCCESS;
1000280c:	230f      	movs	r3, #15
1000280e:	18fb      	adds	r3, r7, r3
10002810:	2200      	movs	r2, #0
10002812:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loci_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10002814:	230e      	movs	r3, #14
10002816:	18fb      	adds	r3, r7, r3
10002818:	2200      	movs	r2, #0
1000281a:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t stdbyclkfail_status = CLOCK_XMC1_STATUS_SUCCESS;
1000281c:	230d      	movs	r3, #13
1000281e:	18fb      	adds	r3, r7, r3
10002820:	2200      	movs	r2, #0
10002822:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t loss_ext_clock_event_status = CLOCK_XMC1_STATUS_SUCCESS;
10002824:	230c      	movs	r3, #12
10002826:	18fb      	adds	r3, r7, r3
10002828:	2200      	movs	r2, #0
1000282a:	701a      	strb	r2, [r3, #0]
  CLOCK_XMC1_STATUS_t dco1_out_sync_status = CLOCK_XMC1_STATUS_SUCCESS;
1000282c:	230b      	movs	r3, #11
1000282e:	18fb      	adds	r3, r7, r3
10002830:	2200      	movs	r2, #0
10002832:	701a      	strb	r2, [r3, #0]

  XMC_ASSERT("CLOCK_XMC1_Init: CLOCK_XMC1 APP handle pointer uninitialized", (handle != NULL));

  if (handle->init_status == false)
10002834:	687b      	ldr	r3, [r7, #4]
10002836:	781b      	ldrb	r3, [r3, #0]
10002838:	2201      	movs	r2, #1
1000283a:	4053      	eors	r3, r2
1000283c:	b2db      	uxtb	r3, r3
1000283e:	2b00      	cmp	r3, #0
10002840:	d01b      	beq.n	1000287a <CLOCK_XMC1_Init+0x76>

#endif
    }

#endif
    status = (CLOCK_XMC1_STATUS_t)(((uint32_t)loci_event_status) | ((uint32_t)stdbyclkfail_status) |
10002842:	230e      	movs	r3, #14
10002844:	18fa      	adds	r2, r7, r3
10002846:	230d      	movs	r3, #13
10002848:	18fb      	adds	r3, r7, r3
1000284a:	7812      	ldrb	r2, [r2, #0]
1000284c:	781b      	ldrb	r3, [r3, #0]
1000284e:	4313      	orrs	r3, r2
10002850:	b2da      	uxtb	r2, r3
10002852:	230c      	movs	r3, #12
10002854:	18fb      	adds	r3, r7, r3
10002856:	781b      	ldrb	r3, [r3, #0]
10002858:	4313      	orrs	r3, r2
1000285a:	b2d9      	uxtb	r1, r3
1000285c:	230f      	movs	r3, #15
1000285e:	18fb      	adds	r3, r7, r3
10002860:	220b      	movs	r2, #11
10002862:	18ba      	adds	r2, r7, r2
10002864:	7812      	ldrb	r2, [r2, #0]
10002866:	430a      	orrs	r2, r1
10002868:	701a      	strb	r2, [r3, #0]
    		                       ((uint32_t)loss_ext_clock_event_status) | ((uint32_t)dco1_out_sync_status));
    if (CLOCK_XMC1_STATUS_SUCCESS == status)
1000286a:	230f      	movs	r3, #15
1000286c:	18fb      	adds	r3, r7, r3
1000286e:	781b      	ldrb	r3, [r3, #0]
10002870:	2b00      	cmp	r3, #0
10002872:	d102      	bne.n	1000287a <CLOCK_XMC1_Init+0x76>
    {
      handle->init_status = true;
10002874:	687b      	ldr	r3, [r7, #4]
10002876:	2201      	movs	r2, #1
10002878:	701a      	strb	r2, [r3, #0]
    }
  }
  return (status);
1000287a:	230f      	movs	r3, #15
1000287c:	18fb      	adds	r3, r7, r3
1000287e:	781b      	ldrb	r3, [r3, #0]
}
10002880:	1c18      	adds	r0, r3, #0
10002882:	46bd      	mov	sp, r7
10002884:	b004      	add	sp, #16
10002886:	bd80      	pop	{r7, pc}

10002888 <SystemCoreClockSetup>:

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
void SystemCoreClockSetup(void)
{
10002888:	b590      	push	{r4, r7, lr}
1000288a:	b085      	sub	sp, #20
1000288c:	af00      	add	r7, sp, #0
/* LOCAL DATA STRUCTURES */
const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC1_0_CONFIG =
1000288e:	1d3b      	adds	r3, r7, #4
10002890:	4a04      	ldr	r2, [pc, #16]	; (100028a4 <SystemCoreClockSetup+0x1c>)
10002892:	ca13      	ldmia	r2!, {r0, r1, r4}
10002894:	c313      	stmia	r3!, {r0, r1, r4}
  .idiv = 1U,  /**< 8 Bit integer divider */

};

  /* Configure FDIV, IDIV, PCLKSEL dividers*/
  XMC_SCU_CLOCK_Init(&CLOCK_XMC1_0_CONFIG);
10002896:	1d3b      	adds	r3, r7, #4
10002898:	1c18      	adds	r0, r3, #0
1000289a:	f7fe fd0d 	bl	100012b8 <XMC_SCU_CLOCK_Init>
}
1000289e:	46bd      	mov	sp, r7
100028a0:	b005      	add	sp, #20
100028a2:	bd90      	pop	{r4, r7, pc}
100028a4:	10002cfc 	.word	0x10002cfc

100028a8 <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
DAVE_STATUS_t DAVE_Init(void)
{
100028a8:	b590      	push	{r4, r7, lr}
100028aa:	b083      	sub	sp, #12
100028ac:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
100028ae:	1dfb      	adds	r3, r7, #7
100028b0:	2200      	movs	r2, #0
100028b2:	701a      	strb	r2, [r3, #0]
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC1_Init(&CLOCK_XMC1_0);
100028b4:	1dfc      	adds	r4, r7, #7
100028b6:	4b1c      	ldr	r3, [pc, #112]	; (10002928 <DAVE_Init+0x80>)
100028b8:	1c18      	adds	r0, r3, #0
100028ba:	f7ff ffa3 	bl	10002804 <CLOCK_XMC1_Init>
100028be:	1c03      	adds	r3, r0, #0
100028c0:	7023      	strb	r3, [r4, #0]

  if (init_status == DAVE_STATUS_SUCCESS)
100028c2:	1dfb      	adds	r3, r7, #7
100028c4:	781b      	ldrb	r3, [r3, #0]
100028c6:	2b00      	cmp	r3, #0
100028c8:	d106      	bne.n	100028d8 <DAVE_Init+0x30>
  {
	 /**  Initialization of PWM APP instance PWM_0 */
	 init_status = (DAVE_STATUS_t)PWM_Init(&PWM_0); 
100028ca:	1dfc      	adds	r4, r7, #7
100028cc:	4b17      	ldr	r3, [pc, #92]	; (1000292c <DAVE_Init+0x84>)
100028ce:	1c18      	adds	r0, r3, #0
100028d0:	f7ff ff1a 	bl	10002708 <PWM_Init>
100028d4:	1c03      	adds	r3, r0, #0
100028d6:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
100028d8:	1dfb      	adds	r3, r7, #7
100028da:	781b      	ldrb	r3, [r3, #0]
100028dc:	2b00      	cmp	r3, #0
100028de:	d106      	bne.n	100028ee <DAVE_Init+0x46>
  {
	 /**  Initialization of PWM APP instance PWM_1 */
	 init_status = (DAVE_STATUS_t)PWM_Init(&PWM_1); 
100028e0:	1dfc      	adds	r4, r7, #7
100028e2:	4b13      	ldr	r3, [pc, #76]	; (10002930 <DAVE_Init+0x88>)
100028e4:	1c18      	adds	r0, r3, #0
100028e6:	f7ff ff0f 	bl	10002708 <PWM_Init>
100028ea:	1c03      	adds	r3, r0, #0
100028ec:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
100028ee:	1dfb      	adds	r3, r7, #7
100028f0:	781b      	ldrb	r3, [r3, #0]
100028f2:	2b00      	cmp	r3, #0
100028f4:	d106      	bne.n	10002904 <DAVE_Init+0x5c>
  {
	 /**  Initialization of PWM APP instance PWM_2 */
	 init_status = (DAVE_STATUS_t)PWM_Init(&PWM_2); 
100028f6:	1dfc      	adds	r4, r7, #7
100028f8:	4b0e      	ldr	r3, [pc, #56]	; (10002934 <DAVE_Init+0x8c>)
100028fa:	1c18      	adds	r0, r3, #0
100028fc:	f7ff ff04 	bl	10002708 <PWM_Init>
10002900:	1c03      	adds	r3, r0, #0
10002902:	7023      	strb	r3, [r4, #0]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
10002904:	1dfb      	adds	r3, r7, #7
10002906:	781b      	ldrb	r3, [r3, #0]
10002908:	2b00      	cmp	r3, #0
1000290a:	d106      	bne.n	1000291a <DAVE_Init+0x72>
  {
	 /**  Initialization of UART APP instance UART_0 */
	 init_status = (DAVE_STATUS_t)UART_Init(&UART_0); 
1000290c:	1dfc      	adds	r4, r7, #7
1000290e:	4b0a      	ldr	r3, [pc, #40]	; (10002938 <DAVE_Init+0x90>)
10002910:	1c18      	adds	r0, r3, #0
10002912:	f7ff f9dd 	bl	10001cd0 <UART_Init>
10002916:	1c03      	adds	r3, r0, #0
10002918:	7023      	strb	r3, [r4, #0]
   }  
  return init_status;
1000291a:	1dfb      	adds	r3, r7, #7
1000291c:	781b      	ldrb	r3, [r3, #0]
} /**  End of function DAVE_Init */
1000291e:	1c18      	adds	r0, r3, #0
10002920:	46bd      	mov	sp, r7
10002922:	b003      	add	sp, #12
10002924:	bd90      	pop	{r4, r7, pc}
10002926:	46c0      	nop			; (mov r8, r8)
10002928:	200005fc 	.word	0x200005fc
1000292c:	2000052c 	.word	0x2000052c
10002930:	20000560 	.word	0x20000560
10002934:	20000594 	.word	0x20000594
10002938:	20000520 	.word	0x20000520

1000293c <main>:
void delay(uint32_t time) {
	for (uint8_t i = 0; i < time; i++)
		;
}

int main(void) {
1000293c:	b590      	push	{r4, r7, lr}
1000293e:	b087      	sub	sp, #28
10002940:	af00      	add	r7, sp, #0
	DAVE_STATUS_t status;
	UART_STATUS_t init_status;

	uint8_t col[3];
	uint8_t startMsg[] = "Running...";
10002942:	1d3b      	adds	r3, r7, #4
10002944:	4a48      	ldr	r2, [pc, #288]	; (10002a68 <main+0x12c>)
10002946:	ca03      	ldmia	r2!, {r0, r1}
10002948:	c303      	stmia	r3!, {r0, r1}
1000294a:	8811      	ldrh	r1, [r2, #0]
1000294c:	8019      	strh	r1, [r3, #0]
1000294e:	7892      	ldrb	r2, [r2, #2]
10002950:	709a      	strb	r2, [r3, #2]

	status = DAVE_Init(); /* Initialization of DAVE APPs  */
10002952:	2317      	movs	r3, #23
10002954:	18fc      	adds	r4, r7, r3
10002956:	f7ff ffa7 	bl	100028a8 <DAVE_Init>
1000295a:	1c03      	adds	r3, r0, #0
1000295c:	7023      	strb	r3, [r4, #0]

	if (status != DAVE_STATUS_SUCCESS) {
1000295e:	2317      	movs	r3, #23
10002960:	18fb      	adds	r3, r7, r3
10002962:	781b      	ldrb	r3, [r3, #0]
10002964:	2b00      	cmp	r3, #0
10002966:	d000      	beq.n	1000296a <main+0x2e>
		/* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
		XMC_DEBUG("DAVE APPs initialization failed\n");

		while (1U) {

		}
10002968:	e7fe      	b.n	10002968 <main+0x2c>
	}

	PWM_SetDutyCycle(&PWM_2, 0);		// Red
1000296a:	4b40      	ldr	r3, [pc, #256]	; (10002a6c <main+0x130>)
1000296c:	1c18      	adds	r0, r3, #0
1000296e:	2100      	movs	r1, #0
10002970:	f7ff fef6 	bl	10002760 <PWM_SetDutyCycle>
	PWM_SetDutyCycle(&PWM_1, 0);		// Green
10002974:	4b3e      	ldr	r3, [pc, #248]	; (10002a70 <main+0x134>)
10002976:	1c18      	adds	r0, r3, #0
10002978:	2100      	movs	r1, #0
1000297a:	f7ff fef1 	bl	10002760 <PWM_SetDutyCycle>
	PWM_SetDutyCycle(&PWM_0, 0);		// Blue
1000297e:	4b3d      	ldr	r3, [pc, #244]	; (10002a74 <main+0x138>)
10002980:	1c18      	adds	r0, r3, #0
10002982:	2100      	movs	r1, #0
10002984:	f7ff feec 	bl	10002760 <PWM_SetDutyCycle>

	init_status = (UART_STATUS_t) UART_Init(&UART_0);
10002988:	2316      	movs	r3, #22
1000298a:	18fc      	adds	r4, r7, r3
1000298c:	4b3a      	ldr	r3, [pc, #232]	; (10002a78 <main+0x13c>)
1000298e:	1c18      	adds	r0, r3, #0
10002990:	f7ff f99e 	bl	10001cd0 <UART_Init>
10002994:	1c03      	adds	r3, r0, #0
10002996:	7023      	strb	r3, [r4, #0]
	if (init_status == UART_STATUS_SUCCESS) {
10002998:	2316      	movs	r3, #22
1000299a:	18fb      	adds	r3, r7, r3
1000299c:	781b      	ldrb	r3, [r3, #0]
1000299e:	2b00      	cmp	r3, #0
100029a0:	d160      	bne.n	10002a64 <main+0x128>
		UART_Transmit(&UART_0, startMsg, sizeof(startMsg) - 1);
100029a2:	4a35      	ldr	r2, [pc, #212]	; (10002a78 <main+0x13c>)
100029a4:	1d3b      	adds	r3, r7, #4
100029a6:	1c10      	adds	r0, r2, #0
100029a8:	1c19      	adds	r1, r3, #0
100029aa:	220a      	movs	r2, #10
100029ac:	f7ff f9a8 	bl	10001d00 <UART_Transmit>
		while (1) {
			if (UART_Receive(&UART_0, col, 1) == UART_STATUS_SUCCESS) {
100029b0:	4a31      	ldr	r2, [pc, #196]	; (10002a78 <main+0x13c>)
100029b2:	2310      	movs	r3, #16
100029b4:	18fb      	adds	r3, r7, r3
100029b6:	1c10      	adds	r0, r2, #0
100029b8:	1c19      	adds	r1, r3, #0
100029ba:	2201      	movs	r2, #1
100029bc:	f7ff f9c6 	bl	10001d4c <UART_Receive>
100029c0:	1e03      	subs	r3, r0, #0
100029c2:	d14e      	bne.n	10002a62 <main+0x126>
				if(col[0] == 1) color(10000, 0, 0);
100029c4:	2310      	movs	r3, #16
100029c6:	18fb      	adds	r3, r7, r3
100029c8:	781b      	ldrb	r3, [r3, #0]
100029ca:	2b01      	cmp	r3, #1
100029cc:	d105      	bne.n	100029da <main+0x9e>
100029ce:	4b2b      	ldr	r3, [pc, #172]	; (10002a7c <main+0x140>)
100029d0:	1c18      	adds	r0, r3, #0
100029d2:	2100      	movs	r1, #0
100029d4:	2200      	movs	r2, #0
100029d6:	f000 f853 	bl	10002a80 <color>
				if(col[0] == 2) color(0, 10000, 0);
100029da:	2310      	movs	r3, #16
100029dc:	18fb      	adds	r3, r7, r3
100029de:	781b      	ldrb	r3, [r3, #0]
100029e0:	2b02      	cmp	r3, #2
100029e2:	d105      	bne.n	100029f0 <main+0xb4>
100029e4:	4b25      	ldr	r3, [pc, #148]	; (10002a7c <main+0x140>)
100029e6:	2000      	movs	r0, #0
100029e8:	1c19      	adds	r1, r3, #0
100029ea:	2200      	movs	r2, #0
100029ec:	f000 f848 	bl	10002a80 <color>
				if(col[0] == 3) color(0, 0, 10000);
100029f0:	2310      	movs	r3, #16
100029f2:	18fb      	adds	r3, r7, r3
100029f4:	781b      	ldrb	r3, [r3, #0]
100029f6:	2b03      	cmp	r3, #3
100029f8:	d105      	bne.n	10002a06 <main+0xca>
100029fa:	4b20      	ldr	r3, [pc, #128]	; (10002a7c <main+0x140>)
100029fc:	2000      	movs	r0, #0
100029fe:	2100      	movs	r1, #0
10002a00:	1c1a      	adds	r2, r3, #0
10002a02:	f000 f83d 	bl	10002a80 <color>
				if(col[0] == 4) color(10000, 0, 10000);
10002a06:	2310      	movs	r3, #16
10002a08:	18fb      	adds	r3, r7, r3
10002a0a:	781b      	ldrb	r3, [r3, #0]
10002a0c:	2b04      	cmp	r3, #4
10002a0e:	d106      	bne.n	10002a1e <main+0xe2>
10002a10:	4a1a      	ldr	r2, [pc, #104]	; (10002a7c <main+0x140>)
10002a12:	4b1a      	ldr	r3, [pc, #104]	; (10002a7c <main+0x140>)
10002a14:	1c10      	adds	r0, r2, #0
10002a16:	2100      	movs	r1, #0
10002a18:	1c1a      	adds	r2, r3, #0
10002a1a:	f000 f831 	bl	10002a80 <color>
				if(col[0] == 5) color(0, 10000, 10000);
10002a1e:	2310      	movs	r3, #16
10002a20:	18fb      	adds	r3, r7, r3
10002a22:	781b      	ldrb	r3, [r3, #0]
10002a24:	2b05      	cmp	r3, #5
10002a26:	d106      	bne.n	10002a36 <main+0xfa>
10002a28:	4a14      	ldr	r2, [pc, #80]	; (10002a7c <main+0x140>)
10002a2a:	4b14      	ldr	r3, [pc, #80]	; (10002a7c <main+0x140>)
10002a2c:	2000      	movs	r0, #0
10002a2e:	1c11      	adds	r1, r2, #0
10002a30:	1c1a      	adds	r2, r3, #0
10002a32:	f000 f825 	bl	10002a80 <color>
				if(col[0] == 6) color(10000, 10000, 0);
10002a36:	2310      	movs	r3, #16
10002a38:	18fb      	adds	r3, r7, r3
10002a3a:	781b      	ldrb	r3, [r3, #0]
10002a3c:	2b06      	cmp	r3, #6
10002a3e:	d106      	bne.n	10002a4e <main+0x112>
10002a40:	4a0e      	ldr	r2, [pc, #56]	; (10002a7c <main+0x140>)
10002a42:	4b0e      	ldr	r3, [pc, #56]	; (10002a7c <main+0x140>)
10002a44:	1c10      	adds	r0, r2, #0
10002a46:	1c19      	adds	r1, r3, #0
10002a48:	2200      	movs	r2, #0
10002a4a:	f000 f819 	bl	10002a80 <color>
				if(col[0] == 7) color(0, 0, 0);
10002a4e:	2310      	movs	r3, #16
10002a50:	18fb      	adds	r3, r7, r3
10002a52:	781b      	ldrb	r3, [r3, #0]
10002a54:	2b07      	cmp	r3, #7
10002a56:	d104      	bne.n	10002a62 <main+0x126>
10002a58:	2000      	movs	r0, #0
10002a5a:	2100      	movs	r1, #0
10002a5c:	2200      	movs	r2, #0
10002a5e:	f000 f80f 	bl	10002a80 <color>
			}
		}
10002a62:	e7a5      	b.n	100029b0 <main+0x74>

	} else {
		XMC_DEBUG("APPLICATION FAILED!!!");
		while (1U) {
		}
10002a64:	e7fe      	b.n	10002a64 <main+0x128>
10002a66:	46c0      	nop			; (mov r8, r8)
10002a68:	10002d08 	.word	0x10002d08
10002a6c:	20000594 	.word	0x20000594
10002a70:	20000560 	.word	0x20000560
10002a74:	2000052c 	.word	0x2000052c
10002a78:	20000520 	.word	0x20000520
10002a7c:	00002710 	.word	0x00002710

10002a80 <color>:
	}
	return 1U;

}

void color(uint16_t red, uint16_t green, uint16_t blue) {
10002a80:	b590      	push	{r4, r7, lr}
10002a82:	b083      	sub	sp, #12
10002a84:	af00      	add	r7, sp, #0
10002a86:	1c04      	adds	r4, r0, #0
10002a88:	1c08      	adds	r0, r1, #0
10002a8a:	1c11      	adds	r1, r2, #0
10002a8c:	1dbb      	adds	r3, r7, #6
10002a8e:	1c22      	adds	r2, r4, #0
10002a90:	801a      	strh	r2, [r3, #0]
10002a92:	1d3b      	adds	r3, r7, #4
10002a94:	1c02      	adds	r2, r0, #0
10002a96:	801a      	strh	r2, [r3, #0]
10002a98:	1cbb      	adds	r3, r7, #2
10002a9a:	1c0a      	adds	r2, r1, #0
10002a9c:	801a      	strh	r2, [r3, #0]
	PWM_SetDutyCycle(&PWM_2, red);
10002a9e:	1dbb      	adds	r3, r7, #6
10002aa0:	881b      	ldrh	r3, [r3, #0]
10002aa2:	4a0b      	ldr	r2, [pc, #44]	; (10002ad0 <color+0x50>)
10002aa4:	1c10      	adds	r0, r2, #0
10002aa6:	1c19      	adds	r1, r3, #0
10002aa8:	f7ff fe5a 	bl	10002760 <PWM_SetDutyCycle>
	PWM_SetDutyCycle(&PWM_1, green);
10002aac:	1d3b      	adds	r3, r7, #4
10002aae:	881b      	ldrh	r3, [r3, #0]
10002ab0:	4a08      	ldr	r2, [pc, #32]	; (10002ad4 <color+0x54>)
10002ab2:	1c10      	adds	r0, r2, #0
10002ab4:	1c19      	adds	r1, r3, #0
10002ab6:	f7ff fe53 	bl	10002760 <PWM_SetDutyCycle>
	PWM_SetDutyCycle(&PWM_0, blue);
10002aba:	1cbb      	adds	r3, r7, #2
10002abc:	881b      	ldrh	r3, [r3, #0]
10002abe:	4a06      	ldr	r2, [pc, #24]	; (10002ad8 <color+0x58>)
10002ac0:	1c10      	adds	r0, r2, #0
10002ac2:	1c19      	adds	r1, r3, #0
10002ac4:	f7ff fe4c 	bl	10002760 <PWM_SetDutyCycle>
}
10002ac8:	46bd      	mov	sp, r7
10002aca:	b003      	add	sp, #12
10002acc:	bd90      	pop	{r4, r7, pc}
10002ace:	46c0      	nop			; (mov r8, r8)
10002ad0:	20000594 	.word	0x20000594
10002ad4:	20000560 	.word	0x20000560
10002ad8:	2000052c 	.word	0x2000052c

10002adc <__aeabi_uidiv>:
10002adc:	2200      	movs	r2, #0
10002ade:	0843      	lsrs	r3, r0, #1
10002ae0:	428b      	cmp	r3, r1
10002ae2:	d374      	bcc.n	10002bce <__aeabi_uidiv+0xf2>
10002ae4:	0903      	lsrs	r3, r0, #4
10002ae6:	428b      	cmp	r3, r1
10002ae8:	d35f      	bcc.n	10002baa <__aeabi_uidiv+0xce>
10002aea:	0a03      	lsrs	r3, r0, #8
10002aec:	428b      	cmp	r3, r1
10002aee:	d344      	bcc.n	10002b7a <__aeabi_uidiv+0x9e>
10002af0:	0b03      	lsrs	r3, r0, #12
10002af2:	428b      	cmp	r3, r1
10002af4:	d328      	bcc.n	10002b48 <__aeabi_uidiv+0x6c>
10002af6:	0c03      	lsrs	r3, r0, #16
10002af8:	428b      	cmp	r3, r1
10002afa:	d30d      	bcc.n	10002b18 <__aeabi_uidiv+0x3c>
10002afc:	22ff      	movs	r2, #255	; 0xff
10002afe:	0209      	lsls	r1, r1, #8
10002b00:	ba12      	rev	r2, r2
10002b02:	0c03      	lsrs	r3, r0, #16
10002b04:	428b      	cmp	r3, r1
10002b06:	d302      	bcc.n	10002b0e <__aeabi_uidiv+0x32>
10002b08:	1212      	asrs	r2, r2, #8
10002b0a:	0209      	lsls	r1, r1, #8
10002b0c:	d065      	beq.n	10002bda <__aeabi_uidiv+0xfe>
10002b0e:	0b03      	lsrs	r3, r0, #12
10002b10:	428b      	cmp	r3, r1
10002b12:	d319      	bcc.n	10002b48 <__aeabi_uidiv+0x6c>
10002b14:	e000      	b.n	10002b18 <__aeabi_uidiv+0x3c>
10002b16:	0a09      	lsrs	r1, r1, #8
10002b18:	0bc3      	lsrs	r3, r0, #15
10002b1a:	428b      	cmp	r3, r1
10002b1c:	d301      	bcc.n	10002b22 <__aeabi_uidiv+0x46>
10002b1e:	03cb      	lsls	r3, r1, #15
10002b20:	1ac0      	subs	r0, r0, r3
10002b22:	4152      	adcs	r2, r2
10002b24:	0b83      	lsrs	r3, r0, #14
10002b26:	428b      	cmp	r3, r1
10002b28:	d301      	bcc.n	10002b2e <__aeabi_uidiv+0x52>
10002b2a:	038b      	lsls	r3, r1, #14
10002b2c:	1ac0      	subs	r0, r0, r3
10002b2e:	4152      	adcs	r2, r2
10002b30:	0b43      	lsrs	r3, r0, #13
10002b32:	428b      	cmp	r3, r1
10002b34:	d301      	bcc.n	10002b3a <__aeabi_uidiv+0x5e>
10002b36:	034b      	lsls	r3, r1, #13
10002b38:	1ac0      	subs	r0, r0, r3
10002b3a:	4152      	adcs	r2, r2
10002b3c:	0b03      	lsrs	r3, r0, #12
10002b3e:	428b      	cmp	r3, r1
10002b40:	d301      	bcc.n	10002b46 <__aeabi_uidiv+0x6a>
10002b42:	030b      	lsls	r3, r1, #12
10002b44:	1ac0      	subs	r0, r0, r3
10002b46:	4152      	adcs	r2, r2
10002b48:	0ac3      	lsrs	r3, r0, #11
10002b4a:	428b      	cmp	r3, r1
10002b4c:	d301      	bcc.n	10002b52 <__aeabi_uidiv+0x76>
10002b4e:	02cb      	lsls	r3, r1, #11
10002b50:	1ac0      	subs	r0, r0, r3
10002b52:	4152      	adcs	r2, r2
10002b54:	0a83      	lsrs	r3, r0, #10
10002b56:	428b      	cmp	r3, r1
10002b58:	d301      	bcc.n	10002b5e <__aeabi_uidiv+0x82>
10002b5a:	028b      	lsls	r3, r1, #10
10002b5c:	1ac0      	subs	r0, r0, r3
10002b5e:	4152      	adcs	r2, r2
10002b60:	0a43      	lsrs	r3, r0, #9
10002b62:	428b      	cmp	r3, r1
10002b64:	d301      	bcc.n	10002b6a <__aeabi_uidiv+0x8e>
10002b66:	024b      	lsls	r3, r1, #9
10002b68:	1ac0      	subs	r0, r0, r3
10002b6a:	4152      	adcs	r2, r2
10002b6c:	0a03      	lsrs	r3, r0, #8
10002b6e:	428b      	cmp	r3, r1
10002b70:	d301      	bcc.n	10002b76 <__aeabi_uidiv+0x9a>
10002b72:	020b      	lsls	r3, r1, #8
10002b74:	1ac0      	subs	r0, r0, r3
10002b76:	4152      	adcs	r2, r2
10002b78:	d2cd      	bcs.n	10002b16 <__aeabi_uidiv+0x3a>
10002b7a:	09c3      	lsrs	r3, r0, #7
10002b7c:	428b      	cmp	r3, r1
10002b7e:	d301      	bcc.n	10002b84 <__aeabi_uidiv+0xa8>
10002b80:	01cb      	lsls	r3, r1, #7
10002b82:	1ac0      	subs	r0, r0, r3
10002b84:	4152      	adcs	r2, r2
10002b86:	0983      	lsrs	r3, r0, #6
10002b88:	428b      	cmp	r3, r1
10002b8a:	d301      	bcc.n	10002b90 <__aeabi_uidiv+0xb4>
10002b8c:	018b      	lsls	r3, r1, #6
10002b8e:	1ac0      	subs	r0, r0, r3
10002b90:	4152      	adcs	r2, r2
10002b92:	0943      	lsrs	r3, r0, #5
10002b94:	428b      	cmp	r3, r1
10002b96:	d301      	bcc.n	10002b9c <__aeabi_uidiv+0xc0>
10002b98:	014b      	lsls	r3, r1, #5
10002b9a:	1ac0      	subs	r0, r0, r3
10002b9c:	4152      	adcs	r2, r2
10002b9e:	0903      	lsrs	r3, r0, #4
10002ba0:	428b      	cmp	r3, r1
10002ba2:	d301      	bcc.n	10002ba8 <__aeabi_uidiv+0xcc>
10002ba4:	010b      	lsls	r3, r1, #4
10002ba6:	1ac0      	subs	r0, r0, r3
10002ba8:	4152      	adcs	r2, r2
10002baa:	08c3      	lsrs	r3, r0, #3
10002bac:	428b      	cmp	r3, r1
10002bae:	d301      	bcc.n	10002bb4 <__aeabi_uidiv+0xd8>
10002bb0:	00cb      	lsls	r3, r1, #3
10002bb2:	1ac0      	subs	r0, r0, r3
10002bb4:	4152      	adcs	r2, r2
10002bb6:	0883      	lsrs	r3, r0, #2
10002bb8:	428b      	cmp	r3, r1
10002bba:	d301      	bcc.n	10002bc0 <__aeabi_uidiv+0xe4>
10002bbc:	008b      	lsls	r3, r1, #2
10002bbe:	1ac0      	subs	r0, r0, r3
10002bc0:	4152      	adcs	r2, r2
10002bc2:	0843      	lsrs	r3, r0, #1
10002bc4:	428b      	cmp	r3, r1
10002bc6:	d301      	bcc.n	10002bcc <__aeabi_uidiv+0xf0>
10002bc8:	004b      	lsls	r3, r1, #1
10002bca:	1ac0      	subs	r0, r0, r3
10002bcc:	4152      	adcs	r2, r2
10002bce:	1a41      	subs	r1, r0, r1
10002bd0:	d200      	bcs.n	10002bd4 <__aeabi_uidiv+0xf8>
10002bd2:	4601      	mov	r1, r0
10002bd4:	4152      	adcs	r2, r2
10002bd6:	4610      	mov	r0, r2
10002bd8:	4770      	bx	lr
10002bda:	e7ff      	b.n	10002bdc <__aeabi_uidiv+0x100>
10002bdc:	b501      	push	{r0, lr}
10002bde:	2000      	movs	r0, #0
10002be0:	f000 f80c 	bl	10002bfc <__aeabi_idiv0>
10002be4:	bd02      	pop	{r1, pc}
10002be6:	46c0      	nop			; (mov r8, r8)

10002be8 <__aeabi_uidivmod>:
10002be8:	2900      	cmp	r1, #0
10002bea:	d0f7      	beq.n	10002bdc <__aeabi_uidiv+0x100>
10002bec:	b503      	push	{r0, r1, lr}
10002bee:	f7ff ff75 	bl	10002adc <__aeabi_uidiv>
10002bf2:	bc0e      	pop	{r1, r2, r3}
10002bf4:	4342      	muls	r2, r0
10002bf6:	1a89      	subs	r1, r1, r2
10002bf8:	4718      	bx	r3
10002bfa:	46c0      	nop			; (mov r8, r8)

10002bfc <__aeabi_idiv0>:
10002bfc:	4770      	bx	lr
10002bfe:	46c0      	nop			; (mov r8, r8)

10002c00 <__libc_init_array>:
10002c00:	4b0e      	ldr	r3, [pc, #56]	; (10002c3c <__libc_init_array+0x3c>)
10002c02:	b570      	push	{r4, r5, r6, lr}
10002c04:	2500      	movs	r5, #0
10002c06:	1c1e      	adds	r6, r3, #0
10002c08:	4c0d      	ldr	r4, [pc, #52]	; (10002c40 <__libc_init_array+0x40>)
10002c0a:	1ae4      	subs	r4, r4, r3
10002c0c:	10a4      	asrs	r4, r4, #2
10002c0e:	42a5      	cmp	r5, r4
10002c10:	d004      	beq.n	10002c1c <__libc_init_array+0x1c>
10002c12:	00ab      	lsls	r3, r5, #2
10002c14:	58f3      	ldr	r3, [r6, r3]
10002c16:	4798      	blx	r3
10002c18:	3501      	adds	r5, #1
10002c1a:	e7f8      	b.n	10002c0e <__libc_init_array+0xe>
10002c1c:	f7fe ff78 	bl	10001b10 <_init>
10002c20:	4b08      	ldr	r3, [pc, #32]	; (10002c44 <__libc_init_array+0x44>)
10002c22:	2500      	movs	r5, #0
10002c24:	1c1e      	adds	r6, r3, #0
10002c26:	4c08      	ldr	r4, [pc, #32]	; (10002c48 <__libc_init_array+0x48>)
10002c28:	1ae4      	subs	r4, r4, r3
10002c2a:	10a4      	asrs	r4, r4, #2
10002c2c:	42a5      	cmp	r5, r4
10002c2e:	d004      	beq.n	10002c3a <__libc_init_array+0x3a>
10002c30:	00ab      	lsls	r3, r5, #2
10002c32:	58f3      	ldr	r3, [r6, r3]
10002c34:	4798      	blx	r3
10002c36:	3501      	adds	r5, #1
10002c38:	e7f8      	b.n	10002c2c <__libc_init_array+0x2c>
10002c3a:	bd70      	pop	{r4, r5, r6, pc}
10002c3c:	200005d8 	.word	0x200005d8
10002c40:	200005d8 	.word	0x200005d8
10002c44:	200005d8 	.word	0x200005d8
10002c48:	200005d8 	.word	0x200005d8
10002c4c:	100015de 	.word	0x100015de
10002c50:	100015de 	.word	0x100015de
10002c54:	100015e8 	.word	0x100015e8
10002c58:	100015e8 	.word	0x100015e8
10002c5c:	1000160a 	.word	0x1000160a
10002c60:	1000160a 	.word	0x1000160a
10002c64:	1000160a 	.word	0x1000160a
10002c68:	1000160a 	.word	0x1000160a
10002c6c:	100015f2 	.word	0x100015f2
10002c70:	100015fe 	.word	0x100015fe

10002c74 <UART_0_channel_config>:
10002c74:	00004b00 10010808 00000000              .K..........

10002c80 <UART_0_tx_pin_config>:
10002c80:	000000b0 00000001                       ........

10002c88 <UART_0_tx_pin>:
10002c88:	40040200 00000001 10002c80              ...@.....,..

10002c94 <UART_0_config>:
10002c94:	10002c74 10002325 00000000 00000000     t,..%#..........
	...
10002cb8:	10002c88 04000000 00000204              .,..........

10002cc4 <UART_0_rx_pin_config>:
10002cc4:	00000000 00000001                       ........

10002ccc <PWM_0_compare_config>:
10002ccc:	00000000 00000004                       ........

10002cd4 <PWM_0_gpio_out_config>:
10002cd4:	00000090 00010000                       ........

10002cdc <PWM_1_compare_config>:
10002cdc:	00000000 00000004                       ........

10002ce4 <PWM_1_gpio_out_config>:
10002ce4:	00000090 00010000                       ........

10002cec <PWM_2_compare_config>:
10002cec:	00000000 00000004                       ........

10002cf4 <PWM_2_gpio_out_config>:
10002cf4:	00000090 00010000 00000100 00010000     ................
10002d04:	00000000 6e6e7552 2e676e69 00002e2e     ....Running.....

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veneer>:
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <CCU40_3_Veneer+0x20>)
    MOV PC,R0
2000000e:	4687      	mov	pc, r0
	...

2000002c <SVC_Veneer>:
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <CCU40_3_Veneer+0x24>)
    MOV PC,R0
2000002e:	4687      	mov	pc, r0
	...

20000038 <PendSV_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <CCU40_3_Veneer+0x28>)
    MOV PC,R0
2000003a:	4687      	mov	pc, r0

2000003c <SysTick_Veneer>:
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <CCU40_3_Veneer+0x2c>)
    MOV PC,R0
2000003e:	4687      	mov	pc, r0

20000040 <SCU_0_Veneer>:
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <CCU40_3_Veneer+0x30>)
    MOV PC,R0
20000042:	4687      	mov	pc, r0

20000044 <SCU_1_Veneer>:
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <CCU40_3_Veneer+0x34>)
    MOV PC,R0
20000046:	4687      	mov	pc, r0

20000048 <SCU_2_Veneer>:
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <CCU40_3_Veneer+0x38>)
    MOV PC,R0
2000004a:	4687      	mov	pc, r0

2000004c <SCU_3_Veneer>:
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <CCU40_3_Veneer+0x3c>)
    MOV PC,R0
2000004e:	4687      	mov	pc, r0

20000050 <SCU_4_Veneer>:
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <CCU40_3_Veneer+0x40>)
    MOV PC,R0
20000052:	4687      	mov	pc, r0

20000054 <SCU_5_Veneer>:
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <CCU40_3_Veneer+0x44>)
    MOV PC,R0
20000056:	4687      	mov	pc, r0

20000058 <SCU_6_Veneer>:
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <CCU40_3_Veneer+0x48>)
    MOV PC,R0
2000005a:	4687      	mov	pc, r0
	...

20000064 <USIC0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
20000064:	4821      	ldr	r0, [pc, #132]	; (200000ec <CCU40_3_Veneer+0x4c>)
    MOV PC,R0
20000066:	4687      	mov	pc, r0

20000068 <USIC0_1_Veneer>:
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
20000068:	4821      	ldr	r0, [pc, #132]	; (200000f0 <CCU40_3_Veneer+0x50>)
    MOV PC,R0
2000006a:	4687      	mov	pc, r0

2000006c <USIC0_2_Veneer>:
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
2000006c:	4821      	ldr	r0, [pc, #132]	; (200000f4 <CCU40_3_Veneer+0x54>)
    MOV PC,R0
2000006e:	4687      	mov	pc, r0

20000070 <USIC0_3_Veneer>:
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
20000070:	4821      	ldr	r0, [pc, #132]	; (200000f8 <CCU40_3_Veneer+0x58>)
    MOV PC,R0
20000072:	4687      	mov	pc, r0

20000074 <USIC0_4_Veneer>:
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000074:	4821      	ldr	r0, [pc, #132]	; (200000fc <CCU40_3_Veneer+0x5c>)
    MOV PC,R0
20000076:	4687      	mov	pc, r0

20000078 <USIC0_5_Veneer>:
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000078:	4821      	ldr	r0, [pc, #132]	; (20000100 <CCU40_3_Veneer+0x60>)
    MOV PC,R0
2000007a:	4687      	mov	pc, r0

2000007c <VADC0_C0_0_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
2000007c:	4821      	ldr	r0, [pc, #132]	; (20000104 <CCU40_3_Veneer+0x64>)
    MOV PC,R0
2000007e:	4687      	mov	pc, r0

20000080 <VADC0_C0_1_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000080:	4821      	ldr	r0, [pc, #132]	; (20000108 <CCU40_3_Veneer+0x68>)
    MOV PC,R0
20000082:	4687      	mov	pc, r0
	...

20000094 <CCU40_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000094:	481d      	ldr	r0, [pc, #116]	; (2000010c <CCU40_3_Veneer+0x6c>)
    MOV PC,R0
20000096:	4687      	mov	pc, r0

20000098 <CCU40_1_Veneer>:
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000098:	481d      	ldr	r0, [pc, #116]	; (20000110 <CCU40_3_Veneer+0x70>)
    MOV PC,R0
2000009a:	4687      	mov	pc, r0

2000009c <CCU40_2_Veneer>:
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
2000009c:	481d      	ldr	r0, [pc, #116]	; (20000114 <CCU40_3_Veneer+0x74>)
    MOV PC,R0
2000009e:	4687      	mov	pc, r0

200000a0 <CCU40_3_Veneer>:
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
200000a0:	481d      	ldr	r0, [pc, #116]	; (20000118 <CCU40_3_Veneer+0x78>)
    MOV PC,R0
200000a2:	4687      	mov	pc, r0
	...
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
200000c0:	10001099 	.word	0x10001099
    .long 0
    
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
200000c4:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
200000c8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
200000cc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
200000d0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
200000d4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
200000d8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
200000dc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
200000e0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
200000e4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
200000e8:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
200000ec:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
200000f0:	10002435 	.word	0x10002435
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
200000f4:	10002421 	.word	0x10002421
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
200000f8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
200000fc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000100:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
20000104:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000108:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
2000010c:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000110:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
20000114:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
20000118:	10001099 	.word	0x10001099
